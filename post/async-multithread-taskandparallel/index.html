<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>改善C#代码的157个建议（6）- 异步，多线程，任务和并行 - Wallis</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="bomir" />
  <meta name="description" content="本节内容 ​ 软件开发过程中， 多线程编码方面的工作看起来比较棘手的；由多线程的 传值、取值、资源同步、线程暂停、取消等操作会困扰每一个尝试编写此类" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.85.0" />


<link rel="canonical" href="https://bomir.top/post/async-multithread-taskandparallel/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="改善C#代码的157个建议（6）- 异步，多线程，任务和并行" />
<meta property="og:description" content="本节内容 ​ 软件开发过程中， 多线程编码方面的工作看起来比较棘手的；由多线程的 传值、取值、资源同步、线程暂停、取消等操作会困扰每一个尝试编写此类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bomir.top/post/async-multithread-taskandparallel/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-23T22:19:05+00:00" />
<meta property="article:modified_time" content="2019-10-23T22:19:05+00:00" />

<meta itemprop="name" content="改善C#代码的157个建议（6）- 异步，多线程，任务和并行">
<meta itemprop="description" content="本节内容 ​ 软件开发过程中， 多线程编码方面的工作看起来比较棘手的；由多线程的 传值、取值、资源同步、线程暂停、取消等操作会困扰每一个尝试编写此类"><meta itemprop="datePublished" content="2019-10-23T22:19:05+00:00" />
<meta itemprop="dateModified" content="2019-10-23T22:19:05+00:00" />
<meta itemprop="wordCount" content="21347">
<meta itemprop="keywords" content="CSharp," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="改善C#代码的157个建议（6）- 异步，多线程，任务和并行"/>
<meta name="twitter:description" content="本节内容 ​ 软件开发过程中， 多线程编码方面的工作看起来比较棘手的；由多线程的 传值、取值、资源同步、线程暂停、取消等操作会困扰每一个尝试编写此类"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">秤流沙</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/about/">关于我</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/Bicomir" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      秤流沙
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/about/">关于我</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/Bicomir" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">改善C#代码的157个建议（6）- 异步，多线程，任务和并行</h1>
      
      <div class="post-meta">
        <time datetime="2019-10-23" class="post-time">
          2019-10-23
        </time>
        <div class="post-category">
            <a href="https://bomir.top/categories/csharp/"> CSharp </a>
            
          </div>
        <span class="more-meta"> 约 21347 字 </span>
          <span class="more-meta"> 预计阅读 43 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#本节内容">本节内容</a></li>
    <li><a href="#一些建议">一些建议</a>
      <ul>
        <li><a href="#建议71区分异步和多线程应用场景">建议71：区分异步和多线程应用场景</a></li>
        <li><a href="#建议72在线程同步中使用信号量">建议72：在线程同步中使用信号量</a></li>
        <li><a href="#建议73避免锁定不恰当的同步对象">建议73：避免锁定不恰当的同步对象</a></li>
        <li><a href="#建议74警惕线程的isbackground">建议74：警惕线程的IsBackground</a></li>
        <li><a href="#建议75警惕线程不会立即启动">建议75：警惕线程不会立即启动</a></li>
        <li><a href="#建议76警惕线程的优先级">建议76：警惕线程的优先级</a></li>
        <li><a href="#建议77正确停止线程">建议77：正确停止线程</a></li>
        <li><a href="#建议78应避免线程数量过多">建议78：应避免线程数量过多</a></li>
        <li><a href="#建议79使用threadpool或backgroundworker代替thread">建议79：使用ThreadPool或BackgroundWorker代替Thread</a></li>
        <li><a href="#建议80用task代替threadpool">建议80：用Task代替ThreadPool</a></li>
        <li><a href="#建议81使用parallel简化同步状态下的task的使用">建议81：使用Parallel简化同步状态下的Task的使用</a></li>
        <li><a href="#建议82parallel简化但不等同于task默认行为">建议82：Parallel简化但不等同于Task默认行为</a></li>
        <li><a href="#建议83小心parallel中的陷阱">建议83：小心Parallel中的陷阱</a></li>
        <li><a href="#建议84使用plinq">建议84：使用PLINQ</a></li>
        <li><a href="#建议85task中的异常处理">建议85：Task中的异常处理</a></li>
        <li><a href="#建议86parallel中的异常处理">建议86：<code>Parallel</code>中的异常处理</a></li>
        <li><a href="#建议87区分wpf和winform的线程模型">建议87：区分WPF和WinForm的线程模型</a></li>
        <li><a href="#建议88并行并不意味着速度更快">建议88：并行并不意味着速度更快</a></li>
        <li><a href="#建议89在并行方法体中谨慎使用锁">建议89：在并行方法体中谨慎使用锁</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="本节内容">本节内容</h2>
<p>​		软件开发过程中， 多线程编码方面的工作看起来比较棘手的；由多线程的 <strong>传值</strong>、<strong>取值</strong>、<strong>资源同步</strong>、<strong>线程暂停</strong>、<strong>取消</strong>等操作会困扰每一个尝试编写此类代码的程序员。微软也做了许多努力，现在在FCL中有丰富的API可供选择，以便编写多线程代码；</p>
<p>​		我们通过具体的例子来熟悉<strong>异步</strong>，<strong>多线程</strong>，<strong>任务和并行</strong>。要了解到异步的本质，任务的实质，以及为什么有了任务还需要一个并行类(Parallel)等问题。 同时要学习到如何优雅的控制线程， 并且处理任务和并行中的异常；</p>
<p>​		多线程是开发人员进阶的一个坎，尝试着学习克服它；</p>
<h2 id="一些建议">一些建议</h2>
<h3 id="建议71区分异步和多线程应用场景">建议71：区分异步和多线程应用场景</h3>
<p>​		对于有一个WinForm界面, 上面有一个按钮，单击这个按钮就可以获取网页的内容并显示出来； 如果该网页内容很多，或者网络状况不好， 这个获取的过程耗时比较长， 这个时候如果顺序地处理界面有可能就会被卡住， 那我们可能会想到新起工作线程的方法来完成这项工作，这样在等待网友内容返回的过程中WinForm就不会被卡住了；写下如下的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Net</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Windows.Forms</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">WindowsFormsApp1</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">Form1</span> <span class="p">:</span> <span class="n">Form</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">Form1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">InitializeComponent</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">buttonGetPage_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">url</span> <span class="p">=</span> <span class="s">&#34;https://www.cnblogs.com/luminji/&#34;</span><span class="p">;</span>
                <span class="kt">var</span> <span class="n">request</span> <span class="p">=</span> <span class="n">HttpWebRequest</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
                <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="n">request</span><span class="p">.</span><span class="n">GetResponse</span><span class="p">();</span>
                <span class="kt">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">response</span><span class="p">.</span><span class="n">GetResponseStream</span><span class="p">();</span>
                <span class="k">using</span> <span class="p">(</span><span class="n">StreamReader</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StreamReader</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="kt">var</span> <span class="n">content</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
                    <span class="n">textBoxPage</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">content</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​		的确，上面的代码解决了页面阻滞的问题， 但是， 它高效吗? 答案是否定的；</p>
<p>​		要理解这一点， 我们需要先来了解IO操作的DMA模式(Direct Memory Access)，即直接内存访问， 是一种不经过CPU而直接进行内存数据存储的数据交换模式。通过DMA的数据交换几乎可以不损耗CPU的资源。在硬件中，硬盘，网卡，网卡，声卡，显卡等都有DMA功能。CLR所提供的异步编程模型就是让我们充分利用硬件的DMA功能来释放CPU的压力；</p>
<p><img src="https://bomir.top/pics/CSharpAdvice/image-20211109170103441.png" alt="image-20211109170103441"></p>
<p>​		为了获取网页， CLR新起了一个工作线程， 然后在读取网页的整个过程中，该工作线程始终阻滞着，直到获取网页完毕为止；在整个过程中，工作线程被占用着，这意味着系统的资源始终被消耗着，等待着；</p>
<p>如果我们修改代码， 使用异步模式来实现， 代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Net</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Windows.Forms</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">WindowsFormsApp1</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">Form1</span> <span class="p">:</span> <span class="n">Form</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">Form1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">InitializeComponent</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">buttonGetPage_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">url</span> <span class="p">=</span> <span class="s">&#34;https://www.cnblogs.com/luminji/&#34;</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">request</span> <span class="p">=</span> <span class="n">HttpWebRequest</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
            <span class="n">request</span><span class="p">.</span><span class="n">BeginGetResponse</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">AsyncCallbackImpl</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">AsyncCallbackImpl</span><span class="p">(</span><span class="n">IAsyncResult</span> <span class="n">ar</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">WebRequest</span> <span class="n">request</span> <span class="p">=</span> <span class="n">ar</span><span class="p">.</span><span class="n">AsyncState</span> <span class="k">as</span> <span class="n">WebRequest</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="n">request</span><span class="p">.</span><span class="n">EndGetResponse</span><span class="p">(</span><span class="n">ar</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">response</span><span class="p">.</span><span class="n">GetResponseStream</span><span class="p">();</span>
            <span class="k">using</span> <span class="p">(</span><span class="n">StreamReader</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StreamReader</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">content</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
                <span class="n">textBoxPage</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">content</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码的工作机制如下图所示：</p>
<p><img src="https://bomir.top/pics/CSharpAdvice/image-20211109171040185.png" alt="image-20211109171040185"></p>
<p>​		经过修改的代码采用了异步的模式， 它使用线程池来管理。新起异步操作后， CLR会将工作丢给线程池的某个工作线程来完成。当开始I/O操作的时候，异步会将工作线程归还给线程池， 这时候就像等于获取网页的工作不会占用任何CPU了。直到异步完成，可见，异步模式借助于线程池， 极大地节约了CPU的资源；</p>
<p>通过上述示例，大概明白了异步和多线程的区别， 进一步我们来确定两者的应用场景：</p>
<ol>
<li>计算密集型工作，采用多线程；</li>
<li><strong>IO密集型工作，采用异步机制；</strong>（涉及到网络、磁盘IO的任务都是IO密集型任务）</li>
</ol>
<h3 id="建议72在线程同步中使用信号量">建议72：在线程同步中使用信号量</h3>
<p>​	线程同步就是指多个线程在某个对象上执行等待(也可理解为锁定该对象)，直到该对象被解除锁定。C#中对象的类型分为引用类型和值类型， CLR在这两种类型上的等待是不一样的；简单的理解就是， 在CLR中，值类型是不能被锁定的，即不能再一个值类型对象上进行等待；而再引用类型上的等待机制，又分为两类： 锁定和信号同步；</p>
<p>​	锁定使用关键字lock和Monitor， 两者实质没区别， 后者其实是语法糖， 这是常用的同步技术；</p>
<p>​	信号同步机制中涉及的类型都继承自抽象类WaitHandle， 这些类型有EventWaitHandle（类型化为AutoResetEvent， ManualResetESvent）、Semaphore以及Mutex。</p>
<p><img src="https://bomir.top/pics/CSharpAdvice/image-20211109173928152.png" alt="image-20211109173928152"></p>
<p>EventWaitHandle子类为AutoResetEvent， ManualResetESvent， Semaphore以及Mutex都继承自WaitHandle，所以它们底层原理是一致的，维护的都是一个系统内核句柄，我们需要简单地为这3个类型做个区分：</p>
<blockquote>
<ol>
<li>EventWaitHandle维护一个由内核产生的布尔类型对象（称为&quot;阻滞状态&quot;），如果其值为false, 那么在它上面等待的线程就阻塞。可以调用类型的Set方将其值设置为true, 解除阻塞; EventWaitHandle子类为AutoResetEvent， ManualResetESvent， 它们的区别不大；</li>
<li>Semaphore维护一个内核产生的整型变量，如果其值为0，则在它上面等待的线程就会阻塞；如果其值大于0，则解除阻塞， 同时， 每解除一个线程阻塞，其值就减1；</li>
<li>EventWaitHandle和Semaphore提供的都是单应用程序域内的线程同步功能，Mutex则不同，它为我们提供了跨应用程序域阻塞和解除阻塞线程的能力；</li>
</ol>
</blockquote>
<p>下面看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="n">AutoResetEvent</span> <span class="n">autoResetEvent</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutoResetEvent</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

<span class="k">private</span> <span class="k">void</span> <span class="n">buttonStartAThread_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Thread</span> <span class="n">tWork</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="s">&#34;线程启动...&#34;</span> <span class="p">+</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">;</span>
        <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">+=</span> <span class="s">&#34;开始处理一些实际的工作&#34;</span> <span class="p">+</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">;</span>
        <span class="c1">//省略工作代码
</span><span class="c1"></span>        <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">+=</span> <span class="s">&#34;我开始等待别的线程给我信号，才愿意继续下去&#34;</span> <span class="p">+</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">;</span>
        <span class="n">autoResetEvent</span><span class="p">.</span><span class="n">WaitOne</span><span class="p">();</span>
        <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">+=</span> <span class="s">&#34;我继续做一些工作，然后结束了！&#34;</span><span class="p">;</span>
        <span class="c1">//省略工作代码
</span><span class="c1"></span>    <span class="p">});</span>
    <span class="n">tWork</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">tWork</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>AutoResetEvent autoResetEvent = new AutoResetEvent(false);</code></p>
<p>这段代码创建了一个同步类型对象autoResetEvent， 它设置自己的默认阻滞状态是false。这意味着任何在它上面进行等待的进程都将被阻滞，所谓等待，就是在线程中应用：</p>
<p><code>autoResetEvent.WaitOne();</code></p>
<p>AutoResetEvent和ManualResetESvent的区别是， 前者在发送信号完毕后（即调用Set方法），会自动将自己的阻滞状态设置为false, 而后者则需要进行手动设定。</p>
<h3 id="建议73避免锁定不恰当的同步对象">建议73：避免锁定不恰当的同步对象</h3>
<p>​		在C#中， 让线程同步的另一种编码的方式就是使用线程锁。线程锁的原理，就是锁住一个资源，使得应用程序在此刻只有一个线程访问该资源。通俗的说，就是多线程变成单线程了，在C#中，可以把锁住的资源理解为new出来的普通的CLR对象；</p>
<p>​		既然需要锁定的对象就是C#中的一个对象， 那么什么样的对象能够成为锁对象（同步对象）呢？在选择同步对象的时候，应当始终注意以下几点：</p>
<ol>
<li>同步对象在需要同步的多个线程中是可见的同一个对象；</li>
<li>在非静态方法中，静态变量不应作为同步对象；</li>
<li>值类型对象不能作为同步对象；</li>
<li>避免将字符串作为同步对象；</li>
<li>降低同步对象的可见性；</li>
</ol>
<p>Note 1: 需要锁定的对象是在多个线程中是可见的， 而且是<strong>同一个对象</strong>。模拟一下啊必须用到锁的场景： 在遍历一个集合的过程中， 同时在另外一个线程中删除集合中的某项。（同时对集合又读又写），如果没有lock语句，将会抛出异常，<code>System.InvalidOperationException 集合已修改；可能无法执行枚举操作</code></p>
<p>Note 2: 在非静态方法中，静态变量不应作为同步对象，要修正第一个note里面的示例问题（生成的两个实例不是同一个对象），这个时候只需要把syncObject变成static。</p>
<p>在编写多线程代码时， 要遵循这样的原则： <strong>类型的静态方法应当保证线程安全，非静态方法不需要实现线程安全；</strong></p>
<p>Note 3：值类型对象不能作为同步对象。值类型在传递给另一个线程的时候，会创建一个副本，这相当于每个线程锁定的也是两个对象。因此，值类型对象不能作为同步对象；</p>
<p>Note 4：锁定字符串完全没有必要， 且很危险；这个过程看起来和值类型正好相反，字符串在CLR中会被暂存到内存中，如果有两个变量分配了相同内容的字符串，那么这两个引用会被指向同一块内存， 所以两个地方同时使用了lock, 其实锁定的是同一个对象，这会导致整个程序被阻滞；</p>
<p>Note 5: 降低同步对象的可见性；可见范围最广的一种同步对象是<code>typeof(SampleClass)</code>， typeof方法所返回的结果是SampleClass所有实例共有的，所有实例的type都指typeof方法的结果；在编写代码的时候，应当始终考虑降低同步对象的可见性， 将同步对象隐藏起来， 只开放给自己或者自己的子类（实际上需要开放给自己的子类的情况都不多）；</p>
<h3 id="建议74警惕线程的isbackground">建议74：警惕线程的IsBackground</h3>
<p>​		在CLR中， 线程分为前台线程和后台线程， 即每个线程都有一个IsBackground属性。两者在表现形式上的唯一区别是：如果前台线程不退出，应用程序的进程就会一直存在，必须所有的前台线程全部退出，应用程序才算退出。而后台线程则没有这个方面的限制，如果应用程序退出，后台线程也会一并退出；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice74</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;线程开始工作...&#34;</span><span class="p">);</span>
                <span class="c1">// 省略工作代码
</span><span class="c1"></span>                <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;线程结束&#34;</span><span class="p">);</span>
            <span class="p">});</span>

            <span class="c1">// 注意， 默认为false
</span><span class="c1"></span>            <span class="n">t</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程完毕!&#34;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​		用Thread创建的线程默认是前台线程， 也就是IsBackground默认属性为false， 上面的代码运行起来要敲一个按键应用程序才会结束; 而如果设置IsBackground为true, 应用程序就会立刻结束；</p>
<p>​		代码demo使用的是Thread， 但我们要注意线程池中的线程默认都是后台线程；</p>
<p>​		基于前后台的线程的区别， 在实际编码中应该更多地使用后台线程。<strong>只有在非常关键的工作中， 如线程正在执行事务或占有的某些非托管资源需要释放时，才使用前台线程；</strong></p>
<h3 id="建议75警惕线程不会立即启动">建议75：警惕线程不会立即启动</h3>
<p>​		现代的大多数操作系统都不是实时的操作系统， Windows操作系统亦是如此；因此，线程并不是立即启动的，Windows内部会实现特殊的算法以进行线程之间的调度，在某个具体的时刻，它会决定当前应该运行哪个线程，反映到最底层就是某个线程分配到了一定的CPU时间， 可用来执行一小段工作(由于被分配的CPU时间很短，即使操作系统中运行了上千个线程， 我们也会觉得这些应用程序是在同时执行的)。Windows会选择在适当时间根据自己的算法决定下一段CPU时间如何调度。</p>
<p>​		线程的调度是相当复杂的一个过程，我们需要理解的是： 线程之间的调度占有一定的时间和空间开销，并且不是实时的；demo（将0-9分别传给10个不同的线程）如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice75</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="m">_</span><span class="n">id</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++,</span> <span class="m">_</span><span class="n">id</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
                <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;{0}:{1}&#34;</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="m">_</span><span class="n">id</span><span class="p">));</span>
                <span class="p">});</span>
                <span class="n">t</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;Thread{0}&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="n">t</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 代码可能输出的结果是：
</span><span class="c1"></span><span class="n">Thread0</span><span class="p">:</span><span class="m">1</span>
<span class="n">Thread2</span><span class="p">:</span><span class="m">2</span>
<span class="n">Thread1</span><span class="p">:</span><span class="m">2</span>
<span class="n">Thread3</span><span class="p">:</span><span class="m">4</span>
<span class="n">Thread4</span><span class="p">:</span><span class="m">5</span>
<span class="n">Thread5</span><span class="p">:</span><span class="m">5</span>
<span class="n">Thread6</span><span class="p">:</span><span class="m">7</span>
<span class="n">Thread7</span><span class="p">:</span><span class="m">8</span>
<span class="n">Thread8</span><span class="p">:</span><span class="m">9</span>
<span class="n">Thread9</span><span class="p">:</span><span class="m">9</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码从两个方面验证了线程不是立即启动的；</p>
<p>首先， 线程并没有按照顺序启动；在代码逻辑中， 前面Start的那个线程也许会迟于后面Start的那个线程执行；</p>
<p>其次，传入线程内部的ID值，不再是for循环执行中当前的ID值。以Thread7为例， 在for循环中， 其当前的值为7， 而Thread7真正得到执行的时候，ID却已经跳出循环，早已经变成8了；</p>
<p>如果我们想要得到需求正确的代码， 需要把上面的for循环修改成为一段同步代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice75</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="m">_</span><span class="n">id</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++,</span> <span class="m">_</span><span class="n">id</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">NewMethod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="m">_</span><span class="n">id</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">NewMethod</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">realTimeID</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;{0}:{1}&#34;</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">realTimeID</span><span class="p">));</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;Thread{0}&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 可能的一个运行结果是:
</span><span class="c1"></span><span class="n">Thread0</span><span class="p">:</span><span class="m">0</span>
<span class="n">Thread2</span><span class="p">:</span><span class="m">2</span>
<span class="n">Thread1</span><span class="p">:</span><span class="m">1</span>
<span class="n">Thread3</span><span class="p">:</span><span class="m">3</span>
<span class="n">Thread4</span><span class="p">:</span><span class="m">4</span>
<span class="n">Thread5</span><span class="p">:</span><span class="m">5</span>
<span class="n">Thread6</span><span class="p">:</span><span class="m">6</span>
<span class="n">Thread7</span><span class="p">:</span><span class="m">7</span>
<span class="n">Thread8</span><span class="p">:</span><span class="m">8</span>
<span class="n">Thread9</span><span class="p">:</span><span class="m">9</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然线程还是保持了不会立即启动的特点， 但是传入线程的ID值， 由于在for循环内部变成了同步代码， 所以能正确传入；</p>
<h3 id="建议76警惕线程的优先级">建议76：警惕线程的优先级</h3>
<p>​		线程在C#中有5个优先级， Highest, AboveNormal, Normal, BelowNormal和Lowest。讲到线程的优先级， 就会涉及线程的调度。Windows是一个基于优先级的抢占式调度系统。在系统中， 如果有一个线程的优先级较高，并且它正好处在就绪状态， 系统总是会优先运行该线程；换句话说， 高优先级的线程总是在系统调度算法中获取更多的CPU执行时间；</p>
<p>​	我们在一个单CPU系统中测试下面的代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice76</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">long</span> <span class="n">t1Num</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="kt">long</span> <span class="n">t2Num</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>

            <span class="n">Thread</span> <span class="n">t1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="k">true</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">t1Num</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="n">t1</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">t1</span><span class="p">.</span><span class="n">Priority</span> <span class="p">=</span> <span class="n">ThreadPriority</span><span class="p">.</span><span class="n">Highest</span><span class="p">;</span>
            <span class="n">t1</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>

            <span class="n">Thread</span> <span class="n">t2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="k">true</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">t2Num</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">});</span>

            <span class="n">t2</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">t2</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>

            <span class="c1">// 停止线程
</span><span class="c1"></span>            <span class="n">cts</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;t1Num:&#34;</span> <span class="p">+</span> <span class="n">t1Num</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;t2Num:&#34;</span> <span class="p">+</span> <span class="n">t2Num</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>

        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>（结论摘抄）结果我们会发现， 如果这段程序运行在单核计算机中， 优先级为Highest的线程t1, 其输出值几乎总是会大于优先级为Normal（默认）的线程t2;</p>
<p>​		在C#中， 使用Thread和ThreadPool新起的线程， 默认的优先级都是Normal。虽然可以像上述代码去修改线程的优先，但是一般不建议这么做；当然， 如果是一些非常关键的线程， 还是可以提升线程的优先级的； <strong>这些关键线程应当具有运行时间短，能即刻进入等待状态等特征</strong>。</p>
<h3 id="建议77正确停止线程">建议77：正确停止线程</h3>
<p>​		devloper总希望对代码有更多的一些控制， 例如， ”让那个还在工作的线程马上停止下来“， 但是实际上， 不是我们想怎么样的就能怎么样， 至少得处理好这两个问题；</p>
<p>​		<strong>第一个问题</strong>	正如线程不能立即启动一样， 线程也不是说停就停的。无论采用何种方式通知工作线程需要停止， 工作线程都会忙完手头最紧要的活，然后在它觉得合适的时候退出。以最传统的Thread.Abort方法为例， 如果线程当前正在执行的是一段非托管的代码， 那么CLR就不会抛出ThreadAbortException，只有在代码继续回到CLR中时，只有当代码继续回到CLR中时，才会引发ThreadAbortException。当然， 即便是在CLR环境中， ThreadAbortException也不会立即触发；</p>
<p>​		<strong>第二个问题</strong>	要正确停止线程，不在于调用者采取了什么行为（如最开始的Thread.Abort()方法），而更多依赖于工作线程是否能主动响应调用者的停止请求。大体机制是，如果线程需要被停止， 那么线程自身就应该给调用者开放这样的接口： Canceled。线程在工作的同时， 还要以某种频率检测Canceled标识，若检测到Canceled，线程自己才会负责退出；</p>
<p>​		FCL现在为我们提供了标准的取消模式： 协作式取消(Cooperative Cancellation)。协作式取消的机制就是上文第二个问题所提到的机制。下面是一个最基础的协作式取消的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice77</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>
            <span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;线程被终止! &#34;</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
                    <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
            <span class="n">cts</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​		调用者使用CancellationTokenSource的Cancel方法通知工作线程退出。工作线程则以<code>1000ms</code>的频率一边工作，一边检查是否有外界传入的Cancel信号，若有这样的信号，则退出；可以看到，在正确停止线程的机制中，真正起到重要作用的是线程本身。示例中工作代码比较简单，但足以说明问题；更复杂的计算式工作，也应该用这样一种方式，妥善而正确地处理问题；</p>
<p>​		协作式取消中的关键类型是CancellationTokenSource， 它有一个关键的属性Token， Token是一个名为CancellationToken的值类型， CancellationToken继而进一步提供了bool值的属性IsCancellationRequested</p>
<p>作为需要取消工作的标识， CancellationToken还有一个方法尤其值得注意，那就是Register方法。它负责传递一个Action委托，在线程停止的时候被回调， 使用方法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">.</span><span class="n">Register</span><span class="p">(()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;工作线程被终止了.&#34;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>例子中使用了Thread进行了演示， 如果使用ThreadPool也是一样的模式。对于任务的Task， 它依赖于CancellationTokenSource和 CancellationToken完成了所有的取消控制；</p>
<h3 id="建议78应避免线程数量过多">建议78：应避免线程数量过多</h3>
<p>​		多数情况下， 创建过多的线程意味者应用程序的架构设计可能存在着缺陷。那么可能有这么一个问题，一个应用程序中应该有多少线程是合理的。以PC机为例， 打开Windows的任务管理器，看看操作系统中正在运行的程序有多少个线程；</p>
<p>​		从本人的PC机来看， 线程数教多的应用软件是360安全卫士软件， 一共有152个线程数；Windows自身的System进程，当前有167个线程；接着是WPS的124个线程， 剩下的是80多， 60多个线程的进程， 还有60多个进程， 每个进程平均10来个线程的样子。 因此来讲，大部分应用程序的线程数不会太多；</p>
<p>​		错误地创建过多线程的一个典型的例子是：</p>
<blockquote>
<p>​		为每一个Socket连接建立一个线程去管理。每个连接一个线程，意味着在32位系统的服务器不能同时管理超过约1000台的客户机。CLR为每个线程分配的内存会超过<code>1MB</code>。约1000个线程，加上.NET进程启动本身所占用的一些内存，即刻就耗尽了系统能分配给进程的最大可用地址空间<code>2GB</code>。即便应用程序在设计之初的需求设计书中说明，生产环境中客户端数目不会超过500台，在管理这500台客户端时进行线程上下文切换，也会损耗相当多的CPU时间。这类I/O密集型场合应该使用异步去完成（请参考建议71的相关阐述）。</p>
<p>​		过多的线程还会带来另外的问题：新起的线程可能需要等待相当长的时间才会真正运行。这是一个相当无奈的结果，在多数情况下，我们都不能忍受等待这么长时间。以下的这段测试代码，在我的系统中，经过了大概5s的时间，才运行到了线程T201：</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice78</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">200</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> 
                <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">j</span><span class="p">++;</span>
                    <span class="p">}</span>
                    <span class="n">t</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
                <span class="p">});</span>
            <span class="p">}</span>

            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span>
            <span class="n">Thread</span> <span class="n">T201</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;T201正在执行！&#34;</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="n">T201</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除了启动问题外，线程之间的切换也存在同样的问题，T201的下一次执行，还会等待相当长的时间。</p>
<p>所以，不要滥用线程，尤其不要滥用过多的线程。当新起线程的时候，需要仔细思考这项工作是否真的需要新起线程去完成。即使真的需要线程也应该考虑使用线程池技术。例如本建议所提到的Socket连接这样的I/O密集型场合，应当始终考虑使用异步来完成。异步会在后台使用线程池进行管理。1000台客户端在使用了异步技术后，实际只要几个线程就能完成所有的管理工作（具体取决于“心跳频率”）。</p>
<h3 id="建议79使用threadpool或backgroundworker代替thread">建议79：使用ThreadPool或BackgroundWorker代替Thread</h3>
<p>使用线程能极大地提升用户体验度，但是作为开发者应该注意到，线程的开销是很大的。</p>
<p>线程的空间开销来自：</p>
<ul>
<li>
<p>线程内核对象（Thread Kernel Object）。每个线程都会创建一个这样的对象，它主要包含线程上下文信息，在32位系统中，它所占用的内存在700字节左右。</p>
</li>
<li>
<p>线程环境块（Thread Environment Block）。TEB包括线程的异常处理链，32位系统中占用<code>4KB</code>内存。</p>
</li>
<li>
<p>用户模式栈（User Mode Stack），即线程栈。线程栈用于保存方法的参数、局部变量和返回值。每个线程栈占用<code>1024KB</code>的内存。要用完这些内存很简单，写一个不能结束的递归方法，让方法参数和返回值不停地消耗内存，很快就会发生OutOfMemoryException。</p>
</li>
<li>
<p>内核模式栈（Kernel Mode Stack）。当调用操作系统的内核模式函数时，系统会将函数参数从用户模式栈复制到内核模式栈。在32位系统中，内核模式栈会占用<code>12KB</code>内存。</p>
</li>
</ul>
<p>线程的时间开销来自：</p>
<ol>
<li>线程创建的时候，系统相继初始化以上这些内存空间。</li>
<li>接着CLR会调用所有加载<code>DLL</code>的<code>DLLMain</code>方法，并传递连接标志（线程终止的时候，也会调用<code>DLL</code>的<code>DLLMain</code>方法，并传递分离标志）。</li>
<li>线程上下文切换。一个系统中会加载很多的进程，而一个进程又包含若干个线程。但是一个CPU在任何时候都只能有一个线程在执行。为了让每个线程看上去都在运行，系统会不断地切换“线程上下文”：每个线程大概得到几十毫秒的执行时间片，然后就会切换到下一个线程了。这个过程大概又分为以下5个步骤：</li>
</ol>
<ul>
<li>
<p><strong>步骤1</strong> 进入内核模式。</p>
</li>
<li>
<p><strong>步骤2</strong>　将上下文信息（主要是一些CPU 寄存器信息）保存到正在执行的线程内核对象上。</p>
</li>
<li>
<p><strong>步骤3</strong>　系统获取一个 Spinlock，并确定下一个要执行的线程，然后释放 Spinlock。如果下一个线程不在同一个进程内，则需要进行虚拟地址交换。</p>
</li>
<li>
<p><strong>步骤4</strong>　从将被执行的线程内核对象上载入上下文信息。</p>
</li>
<li>
<p><strong>步骤5</strong>　离开内核模式。</p>
</li>
</ul>
<p>​		由于要进行如此多的工作， 所以创建和销毁一个线程的代价是昂贵的， 为了程序员无节制地使用线程， 微软开发了”线程池“的技术。简单来说， 线程池就是替开发人员管理工作线程。当一项工作完毕时，CLR不会摧毁这个线程，而是会保留这个线程一段时间， 看看有没有别的工作需要这个线程。至于何时销毁或新起线程，由CLR根据自身的算法来做这个决定。所以，如果我们要多线程编码，不应想到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> 
<span class="p">{</span>
    <span class="c1">// work code
</span><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>应该首先想到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="n">ThreadPool</span><span class="p">.</span><span class="n">QueueUserWorkItem</span><span class="p">((</span><span class="n">objState</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>  
    <span class="c1">//工作代码  
</span><span class="c1"></span><span class="p">},</span> <span class="k">null</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>线程池能让我们更关注到业务的实现， 而不是线程的性能测试。</p>
<p>​		书中的此条建议还提到一个类型 BackgroundWorker， BackgroundWorker是在内部使用了线程池的技术；同时，在Winform或WPF编码中，它还给工作线程和UI线程提供了交互的能力。如果我们稍加注意，就会发现：Thread和ThreadPool默认都没有提供这种交互能力，而BackgroundWorker却通过事件提供了这种能力。这种能力包括：报告进度、支持完成回调、取消任务、暂停任务等。一个使用BackgroundWorker的简单示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System.ComponentModel</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Windows.Forms</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice79</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">Form1</span> <span class="p">:</span> <span class="n">Form</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">Form1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">InitializeComponent</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="n">BackgroundWorker</span> <span class="n">worker</span><span class="p">;</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">startAsyncButton_Click</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Object</span> <span class="n">sender</span><span class="p">,</span>
            <span class="n">System</span><span class="p">.</span><span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">worker</span><span class="p">.</span><span class="n">DoWork</span> <span class="p">+=</span> <span class="k">new</span> <span class="n">DoWorkEventHandler</span><span class="p">(</span><span class="n">worker_DoWork</span><span class="p">);</span>
            <span class="n">worker</span><span class="p">.</span><span class="n">ProgressChanged</span> <span class="p">+=</span> <span class="k">new</span> <span class="n">ProgressChangedEventHandler</span><span class="p">(</span><span class="n">worker_ProgressChanged</span><span class="p">);</span>
            <span class="n">worker</span><span class="p">.</span><span class="n">RunWorkerAsync</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">worker_DoWork</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">DoWorkEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">BackgroundWorker</span> <span class="n">worker</span> <span class="p">=</span> <span class="n">sender</span> <span class="k">as</span> <span class="n">BackgroundWorker</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">worker</span><span class="p">.</span><span class="n">ReportProgress</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">worker_ProgressChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ProgressChangedEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">ProgressPercentage</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此示例是一个<code>Winform</code>程序， 从事<code>Winform</code>或WPF开发的程序员，可考虑使用BackgroundWorker；</p>
<h3 id="建议80用task代替threadpool">建议80：用Task代替ThreadPool</h3>
<p>ThreadPool相对于Thread来说有很多优势，但是ThreadPool使用起来却存在一定的不方便， 比如：</p>
<ul>
<li>ThreadPool不支持线程的取消、完成、失败通知等交互性操作。</li>
<li>ThreadPool不支持线程执行的先后次序。</li>
</ul>
<p>以往，如果开发者要实现上述功能，需要完成很多额外的工作。现在，FCL中提供了一个功能更强大的概念：Task。Task在线程池的基础上进行了优化，并提供了更多的API。在FCL 4.0中，如果我们要编写多线程程序，Task显然已经优于传统的方式了。</p>
<p>下面看一个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice80</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务开始工作...&#34;</span><span class="p">);</span>

                <span class="c1">// 模拟工作过程
</span><span class="c1"></span>                <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">((</span><span class="n">task</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务完成， 完成时候的状态为: &#34;</span><span class="p">);</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;IsCanceled={0}\tIsCompleted={1}\tIsFaulted={2}&#34;</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsCanceled</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>任务Task具备以下属性， 可以让我们查询任务完成时的状态：</p>
<ul>
<li><code>IsCanceled</code>		因为被取消而完成</li>
<li><code>IsCompleted</code>      成功完成</li>
<li><code>IsFaulted</code>          因为发生异常而完成</li>
</ul>
<p>​		需要注意的是， 任务没有提供回调事件来通知完成（像BackgroundWorker一样），它是通过启用一个新任务的方式来完成类似的功能。<code>ContinueWith</code>方法可以在一个任务完成的时候发起一个新任务，这种方式天然就支持了任务的完成通知：我们可以在新任务中获取原任务的结果值。</p>
<p>下面是一个稍微复杂的例子， 同时支持完成通知、取消、获取任务返回值等功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice80</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>
            <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">Add</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">),</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">TaskEnd</span><span class="p">);</span>

            <span class="c1">// 等待按任意键取消任务
</span><span class="c1"></span>            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
            <span class="n">cts</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">TaskEnd</span><span class="p">(</span><span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务完成，完成时候的状态为: &#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;IsCanceled={0}\tIsCompleted={1}\tIsFaulted={2}&#34;</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsCanceled</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务的返回值为: {0}&#34;</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">Add</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务开始...&#34;</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(!</span><span class="n">ct</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">result</span><span class="p">++;</span>
                <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// 开始几秒后，按下按键，运行结果是：
</span><span class="c1"></span><span class="err">任务开始</span><span class="p">...</span>
<span class="err">任务完成，完成时候的状态为</span><span class="p">:</span>
<span class="n">IsCanceled</span><span class="p">=</span><span class="n">False</span>        <span class="n">IsCompleted</span><span class="p">=</span><span class="n">True</span>        <span class="n">IsFaulted</span><span class="p">=</span><span class="n">False</span>
<span class="err">任务的返回值为</span><span class="p">:</span> <span class="m">9</span>
</code></pre></td></tr></table>
</div>
</div><p>也许我们会奇怪， 不是通过按键取消的么， 为什么完成的状态<code>IsCanceled</code>还是为False， 因为在工作任务中，我们对<code>IsCancellationRequested</code> 进行了业务逻辑上的处理， 但是并没有通过<code>ThrowIfCancellationRequested</code>来处理，如果采用<code>ThrowIfCancellationRequested</code>， 代码应当如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice80</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>
            <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="n">AddCancelByThrow</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">),</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">TaskEndByCatch</span><span class="p">);</span>

            <span class="c1">// 等待按任意键取消任务
</span><span class="c1"></span>            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
            <span class="n">cts</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">TaskEndByCatch</span><span class="p">(</span><span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务完成，完成时候的状态为: &#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;IsCanceled={0}\tIsCompleted={1}\tIsFaulted={2}&#34;</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsCanceled</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">IsFaulted</span><span class="p">);</span>

            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务的返回值为: {0}&#34;</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">e</span><span class="p">.</span><span class="n">Handle</span><span class="p">((</span><span class="n">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">err</span> <span class="k">is</span> <span class="n">OperationCanceledException</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">AddCancelByThrow</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务开始...&#34;</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">ct</span><span class="p">.</span><span class="n">ThrowIfCancellationRequested</span><span class="p">();</span>
                <span class="n">result</span><span class="p">++;</span>
                <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 运行结果是：
</span><span class="c1"></span><span class="err">任务开始</span><span class="p">...</span>
<span class="err">任务完成，完成时候的状态为</span><span class="p">:</span>
<span class="n">IsCanceled</span><span class="p">=</span><span class="n">True</span>		<span class="n">IsCompleted</span><span class="p">=</span><span class="n">True</span>	 <span class="n">IsFaulted</span><span class="p">=</span><span class="n">False</span>
</code></pre></td></tr></table>
</div>
</div><p>​		在任务结束求值的方法<code>TaskEndedByCatch</code>中，如果任务是通过<code>ThrowIfCancellation</code> Requested方法结束的，对任务求结果值将会抛出异常<code>OperationCanceledException</code>，而不是得到抛出异常前的结果值。这意味着任务是通过异常的方式被取消掉的，所以可以注意到上面代码的输出中，状态<code>IsCanceled</code>为True。</p>
<p>​		接着来看上面的输出，我们注意到取消是通过异常的方式实现的，而表示任务中发生了异常的<code>IsFaulted</code>状态却还是为False，为什么呢？这是因为<code>ThrowIfCancellation</code> Requested是协作式取消方式的类型CancellationTokenSource中的一个方法，CLR对其进行了特殊的处理。CLR知道这一行程序是开发者有意为之，所以不把它看做是一个异常（它被理解为取消）。要得到<code>IsFaulted</code>等于True的状态，我们可以修改While循环，模拟一个异常出来，具体方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">AddCancelByThrow</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务开始...&#34;</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
    	<span class="c1">// ct.ThrowIfCancellationRequested();
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">==</span> <span class="m">5</span><span class="p">)</span>
        <span class="p">{</span>
        	<span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;error&#34;</span><span class="p">);</span>
        <span class="p">}</span>
   	 	<span class="n">result</span><span class="p">++;</span>
    	<span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 运行结果是：
</span><span class="c1"></span><span class="err">任务开始</span><span class="p">...</span>
<span class="err">任务完成，完成时候的状态为</span><span class="p">:</span>
<span class="n">IsCanceled</span><span class="p">=</span><span class="n">False</span>        <span class="n">IsCompleted</span><span class="p">=</span><span class="n">True</span>        <span class="n">IsFaulted</span><span class="p">=</span><span class="n">True</span>
</code></pre></td></tr></table>
</div>
</div><p>Task还支持任务工厂的概念， 任务工厂支持多个任务之间共享相同的状态，如取消类型CancellationTokenSource是可以被共享的， 通过使用任务工厂， 可以同时取消一组任务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice80</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>
            <span class="n">TaskFactory</span> <span class="n">taskFactory</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskFactory</span><span class="p">();</span>
            <span class="n">Task</span><span class="p">[]</span> <span class="n">tasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">[]</span>
            <span class="p">{</span>
                <span class="n">taskFactory</span><span class="p">.</span><span class="n">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Add</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">)),</span>
                <span class="n">taskFactory</span><span class="p">.</span><span class="n">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Add</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">)),</span>
                <span class="n">taskFactory</span><span class="p">.</span><span class="n">StartNew</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Add</span><span class="p">(</span><span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">)),</span>
            <span class="p">};</span>

            <span class="c1">// CancellationToken.None, 指示TasksEnded不能被取消
</span><span class="c1"></span>            <span class="n">taskFactory</span><span class="p">.</span><span class="n">ContinueWhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">TaskEnded</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
            <span class="n">cts</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">Add</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">ct</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务开始...&#34;</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(!</span><span class="n">ct</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">result</span><span class="p">++;</span>
                <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">TaskEnded</span><span class="p">(</span><span class="n">Task</span><span class="p">[]</span> <span class="n">task</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;所有任务已完成！&#34;</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​		该条建议演示了Task(任务)和TaskFactory(任务工厂)的使用方法， Task进一步优化了后台线程的调度，加快了线程的处理速度。所以在<code>FCL4.x</code>时代， 如果要使用多线程， 我们应该更多的使用Task；</p>
<h3 id="建议81使用parallel简化同步状态下的task的使用">建议81：使用Parallel简化同步状态下的Task的使用</h3>
<p>在命名空间<code>System.threading.Tasks</code>中， 有一个静态类Parallel简化了在同步状态下的Task的操作， Parallel主要有3个有用的方法：<code>For、ForEach、Invoke</code>。</p>
<p>1.For方法主要用于处理针对数组元素的并行操作， 如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice81</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">};</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span> 
            <span class="p">{</span> 
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;ArrayIndex{0} -&gt; Element{1}&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">});</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://bomir.top/pics/CSharpAdvice/image-20211112110009671.png" alt="image-20211112110009671"></p>
<p>​		可以看出，打印的结果并不是按数组的索引次序进行遍历的，这是因为我们的遍历是并行的，不是顺序的；因此，<strong>如果我们是想要的输出必须是同步的或者说是顺序输出的， 则不应该使用Parallel的形式；</strong></p>
<p>​		使用<code>For和ForEach</code>方法，Parallel类型会自动为我们分配Task来完成针对元素的一些工作。当然我们也可以直接使用Task，但是上面的这种形式在语法上更为简洁。</p>
<p>​		Parallel的Invoke方法为我们简化了启动一组并行操作，它隐式启动的就是Task。该方法接受<code>Params Action[ ]</code>参数，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice81</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span>
            <span class="p">()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务1......&#34;</span><span class="p">);</span>
            <span class="p">},</span>
            <span class="p">()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务2......&#34;</span><span class="p">);</span>
            <span class="p">},</span>
            <span class="p">()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务3......&#34;</span><span class="p">);</span>
            <span class="p">},</span>
            <span class="p">()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务4......&#34;</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 可能的输出结果是:
</span><span class="c1"></span><span class="err">任务</span><span class="m">1.</span><span class="p">.....</span>
<span class="err">任务</span><span class="m">3.</span><span class="p">.....</span>
<span class="err">任务</span><span class="m">2.</span><span class="p">.....</span>
<span class="err">任务</span><span class="m">4.</span><span class="p">.....</span>
</code></pre></td></tr></table>
</div>
</div><p>同样的，由于所有的任务都是并行的， 所以它不保证先后顺序；</p>
<h3 id="建议82parallel简化但不等同于task默认行为">建议82：Parallel简化但不等同于Task默认行为</h3>
<p>​		建议81说到了Parallel的使用方法，不知道大家是否注意到文中使用的字眼：在同步状态下简化了Task的使用。也就是说，在运行Parallel中的<code>For、ForEach</code>方法时，调用者线程（在示例中就是主线程）是被阻滞的。Parallel虽然将任务交给Task去处理，即交给CLR线程池去处理，不过调用者会一直等到线程池中的相关工作全部完成。表示并行的静态类Parallel甚至只提供了Invoke方法，而没有同时提供一个<code>BeginInvoke</code>方法，这也从一定程度上说明了这个问题。</p>
<p>​		从使用Task时， 我们最常使用的是Start方法(Task也提供了RunSynchronously), 它不会阻滞调用者线程。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>
<span class="p">});</span>
<span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程即将结束&#34;</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>​		 如果执行这段代码， 永远不会有输出；</p>
<p>​		并行编程，意味者运行时在后台将任务分配到尽量多的CPU上，虽然它在后台使用Task进行管理，但这并不意味者它等同于异步；</p>
<h3 id="建议83小心parallel中的陷阱">建议83：小心Parallel中的陷阱</h3>
<p>​		Parallel的<code>For和ForEach</code>方法还支持一些相对复杂的应用。在这些应用中，它允许在每个任务启动时执行一些初始化的操作，在每个任务结束后，又执行一些后续操作；同时，还允许我们监视**线程（而不是任务）**的状态。</p>
<p>我们需要深刻理解这些具体的操作和应用， 下面去体会这段代码的输出是什么？：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice83</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span> <span class="p">};</span>
            <span class="kt">int</span> <span class="n">total</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="m">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="k">return</span> <span class="m">1</span><span class="p">;</span>    
            <span class="p">},</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">loopState</span><span class="p">,</span> <span class="n">subtotal</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">subtotal</span> <span class="p">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">return</span> <span class="n">subtotal</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Interlocked</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">total</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;total={0}&#34;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码有可能输出11， 较少的情况下输出12，虽然理论上有可能输出13和14，但是我们应该很少有机会观察到。要明白为什么会有这样的输出，首先必须详细了解For方法的各个参数。上面这个For方法的声明如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="na"> [__DynamicallyInvokable]</span>
<span class="k">public</span> <span class="k">static</span> <span class="n">ParallelLoopResult</span> <span class="n">For</span><span class="p">&lt;</span><span class="n">TLocal</span><span class="p">&gt;(</span><span class="kt">int</span> <span class="n">fromInclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">toExclusive</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">TLocal</span><span class="p">&gt;</span> <span class="n">localInit</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">ParallelLoopState</span><span class="p">,</span> <span class="n">TLocal</span><span class="p">,</span> <span class="n">TLocal</span><span class="p">&gt;</span> <span class="n">body</span><span class="p">,</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">TLocal</span><span class="p">&gt;</span> <span class="n">localFinally</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>前面的两个参数相对容易理解， 分别时起始索引和结束索引；</p>
<p>参数body也比较容易理解， 即任务体本身， 其中subtotal为单个任务的返回值；</p>
<p><code>localInit</code>和<code>localFinally</code>就比较难以理解了， 并且陷阱也在这里； 我们需要先去理解<code>Parallel.For</code>方法的运作模式。For方法采用并发的方式来启动循环体中的每个任务，这意味着，任务是交给线程池去管理的。在上面的代码中，循环次数共计4次，实际运行时调度启动的后台线程也就只有一个或两个。这就是并发的优势，也是线程池的优势，Parallel通过内部的调度算法，最大化地节约了线程的消耗。<code>localInit</code>的作用是<strong>如果Parallel为我们新起了一个线程，它就会执行一些初始化的任务</strong>在上面的例子中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"> <span class="p">()</span> <span class="p">=&gt;</span> 
 <span class="p">{</span>
     <span class="k">return</span> <span class="m">1</span><span class="p">;</span>    
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它会将任务体中的subtotal这个值初始化为1。</p>
<p><code>localFinally</code>的作用是，在每个线程结束的时候，它执行一些收尾工作：</p>
<p><code>(x) =&gt; Interlocked.Add(ref total, x) </code></p>
<p>这行代码所代表的收尾工作实际就是：</p>
<p><code>totaltotal = total + subtotal; </code></p>
<p>其中的x，其实代表的就是任务体中的返回值，具体在这个例子中就是subtotal在返回时的值。使用Interlocked是对total使用原子操作，以避免并发所带来的问题。</p>
<p>现在，我们应该很好理解为什么上面这段代码的输出会不确定了。Parallel一共启动了4个任务，但是我们不能确定Parallel到底为我们启动了多少个线程，那是运行时根据自己的调度算法决定的。如果所有的并发任务只用了一个线程，则输出为11；如果用了两个线程，那么根据程序的逻辑来看，输出就是12了。</p>
<p>在这段代码中，如果让<code>localInit</code>返回的值为0，也许你就永远不会注意到这个陷阱：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"> <span class="p">()</span> <span class="p">=&gt;</span> 
 <span class="p">{</span>
     <span class="k">return</span> <span class="m">0</span><span class="p">;</span>    
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>为了更加清晰的理解这个问题， 使用下面这个更好理解的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice83</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">string</span><span class="p">[]</span> <span class="n">stringArr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&#34;aa&#34;</span><span class="p">,</span> <span class="s">&#34;bb&#34;</span><span class="p">,</span> <span class="s">&#34;cc&#34;</span><span class="p">,</span> <span class="s">&#34;dd&#34;</span><span class="p">,</span> <span class="s">&#34;ee&#34;</span><span class="p">,</span> <span class="s">&#34;ff&#34;</span><span class="p">,</span> <span class="s">&#34;gg&#34;</span><span class="p">,</span> <span class="s">&#34;hh&#34;</span><span class="p">};</span>
            <span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">stringArr</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="s">&#34;-&#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">loopState</span><span class="p">,</span> <span class="n">subResult</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">subResult</span> <span class="p">+=</span> <span class="n">stringArr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">},</span> <span class="p">(</span><span class="n">threadEndString</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">result</span> <span class="p">+=</span> <span class="n">threadEndString</span><span class="p">;</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Inner:&#34;</span> <span class="p">+</span> <span class="n">threadEndString</span><span class="p">);</span>
            <span class="p">});</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="建议84使用plinq">建议84：使用PLINQ</h3>
<p>​		LINQ的基本功能就是对集合进行遍历查询， 并在此基础上对元素进行操作。仔细推敲就能发现， 并行编程特别适合这一类应用； 微软特别的为LINQ拓展了一个类ParallelEnumerable（该类型也在命名空间下<code>System.Linq</code>中），它所提供的扩展方法会让<code>Linq</code>支持并行计算， 这就是PLINQ；</p>
<p>​		传统的LINQ计算是单线程的，PLINQ则是并发的、多线程的，我们通过下面这个示例就可以看出这个区别：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice84</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">intlist</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;()</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">};</span>
            <span class="kt">var</span> <span class="n">query</span> <span class="p">=</span> <span class="k">from</span> <span class="n">p</span> <span class="k">in</span> <span class="n">intlist</span> <span class="k">select</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;以下是LINQ的输出: &#34;</span><span class="p">);</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">query</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;以下是PLINQ的输出: &#34;</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">queryParallel</span> <span class="p">=</span> <span class="k">from</span> <span class="n">p</span> <span class="k">in</span> <span class="n">intlist</span><span class="p">.</span><span class="n">AsParallel</span><span class="p">()</span> <span class="k">select</span> <span class="n">p</span><span class="p">;</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">queryParallel</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://bomir.top/pics/CSharpAdvice/image-20211112180206843.png" alt="image-20211112180206843"></p>
<p>LINQ的输出会按照intList中的索引顺序打印出来。而PLINQ的输出是杂乱无章的。</p>
<p>并行输出还有另外一种方式可以处理，那就是对<code>queryParallel求ForAll</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"> <span class="n">queryParallel</span><span class="p">.</span><span class="n">ForAll</span><span class="p">((</span><span class="n">item</span><span class="p">)</span> <span class="p">=&gt;</span>
 <span class="p">{</span>
 	<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
 <span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>但是这种方法会带来一个问题，如果要将并行输出后的结果进行排序，ForAll会忽略掉查询的AsOrdered请求。如下所示， AsOrdered方法可以对并行计算后的队列进行重新组合，以便保持顺序。可是在ForAll方法中，它所完成的输出仍是无序的。如果要保持AsOrdered方法的需求，我们应当始终使用第一种并行方式，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="kt">var</span> <span class="n">queryParallel</span> <span class="p">=</span> <span class="k">from</span> <span class="n">p</span> <span class="k">in</span> <span class="n">intlist</span><span class="p">.</span><span class="n">AsParallel</span><span class="p">().</span><span class="n">AsOrdered</span><span class="p">()</span> <span class="k">select</span> <span class="n">p</span><span class="p">;</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">queryParallel</span><span class="p">)</span>   <span class="c1">// 有序
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;**************Split Line****************&#34;</span><span class="p">);</span>

<span class="n">queryParallel</span><span class="p">.</span><span class="n">ForAll</span><span class="p">((</span><span class="n">item</span><span class="p">)</span> <span class="p">=&gt;</span>        <span class="c1">// 无序
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>在并行查询后再进行排序，会牺牲掉一定的性能。一些扩展方法默认会对元素进行排序，这些方法包括：OrderBy、OrderByDescending、ThenBy和ThenByDescending。在实际的使用中，一定要注意到各种方式之间的差别，以便程序按照我们的设想运行。</p>
<p>还有一些其他的查询方法，比如Take。如果我们这样编码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">item</span> <span class="k">in</span> <span class="n">queryParallel</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">5</span><span class="p">))</span>  
<span class="p">{</span>  
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>  
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>在顺序查询中，会返回前5个元素。但是在PLINQ中，会选出5个无序的元素。</p>
<p>建议在对集合中的元素项进行操作的时候使用PLINQ代替LINQ。但是要记住，不是所有并行查询的速度都会比顺序查询快，在对集合执行某些方法时，顺序查询的速度会更快一点，如方法<code>ElementAt</code>等。在开发中，我们应该仔细辨别这方面的需求，以便找到最佳的解决方案。</p>
<h3 id="建议85task中的异常处理">建议85：Task中的异常处理</h3>
<p>​		在任何时候，异常处理都是非常重要的一个环节。<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a>与并行编程中尤其是这样。如果不处理这些后台任务中的异常，应用程序将会莫名其妙的退出。处理那些不是主线程（如果是窗体程序，那就是UI主线程）产生的异常，最终的办法都是将其包装到主线程上。</p>
<p>​		在任务并行库中，如果对任务运行<code>Wait、WaitAny、WaitAll</code>等方法，或者求Result属性，都能捕获到<code>AggregateException</code>异常。可以将<code>AggregateException</code>异常看做是任务并行库编程中最上层的异常。在任务中捕获的异常，最终都应该包装到<code>AggregateException</code>中。一个任务并行库异常的简单处理示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice85</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;任务并行时候产生的异常&#34;</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>

            <span class="k">try</span>
            <span class="p">{</span>
                <span class="c1">// 若有Result， 可求Result
</span><span class="c1"></span>                <span class="n">t</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">e</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;ExceptionType: {0}{1} from {2}{3} Exception Content:{4}&#34;</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程马上结束!&#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 运行结果是：
</span><span class="c1"></span><span class="n">ExceptionType</span><span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Exception</span>
 <span class="k">from</span> <span class="n">Advice85</span>
 <span class="n">Exception</span> <span class="n">Content</span><span class="p">:</span><span class="err">任务并行时候产生的异常</span>
<span class="err">主线程马上结束</span><span class="p">!</span>
</code></pre></td></tr></table>
</div>
</div><p>大家也许已经注意到，虽然运行<code>Wait、WaitAny、WaitAll</code>方法，或者求Result属性能得到任务的异常信息，但是这会阻滞当前线程。这往往不是我们所希望看到的，岂能为了得到一个异常就故意等待？这时可以考虑任务并行库中Task类型的一个功能：新起一个后续任务，就可以解决等待的问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice85</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;任务并行编码时候产生的未知异常&#34;</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>

            <span class="n">Task</span> <span class="n">ttEnd</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">((</span><span class="n">task</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">task</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;ExceptionType: {0}{1} from {2}{3} Exception Content:{4}&#34;</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">});</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程马上结束!&#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://bomir.top/pics/CSharpAdvice/image-20211112183939963.png" alt="image-20211112183939963"></p>
<p>​		以上方法解决了主线程等待的问题，但是仔细研究我们会发现，异常处理没有回到主线程中，它还是在线程池中。在某些场合，比如对于业务逻辑上特定异常的处理，需要采取这种方式，而且我们也鼓励这种用法。但很明显，更多时候我们还<strong>需要更进一步将异常处理封装到主线程</strong>。</p>
<p>Task没有提供将任务中的异常包装到主线程的接口。一个可行的办法是，仍旧使用类似Wait的方法来达到此目的。在本建议一开始的代码中，我们对于主工作任务采用Wait的方法，这是不可取的。因为主工作任务也许会持续一段较长的时间，那样会阻塞调用者，并让调用者觉得不能忍受。而本建议的第二段代码中，新任务只完成了处理异常，这意味着新任务不会延续较长时间，所以，在这个新任务上维持等待对于调用者来说，是可以忍受的。所以，我们可以采用这个方法将异常包装到主线程中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice85</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;任务并行编码时候产生的未知异常&#34;</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>

            <span class="n">Task</span> <span class="n">ttEnd</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">((</span><span class="n">task</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="n">task</span><span class="p">.</span><span class="n">Exception</span><span class="p">;</span> 
            <span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span><span class="p">);</span>

            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">ttEnd</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">err</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">err</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;ExceptionType: {0} {1} from {2} {3} Exception Content:{4}&#34;</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">InnerException</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">InnerException</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">InnerException</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程马上结束!&#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 程序运行的结果是：
</span><span class="c1"></span><span class="n">ExceptionType</span><span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Exception</span>
 <span class="k">from</span> <span class="n">Advice85</span>
 <span class="n">Exception</span> <span class="n">Content</span><span class="p">:</span><span class="err">任务并行编码时候产生的未知异常</span>
<span class="err">主线程马上结束</span><span class="p">!</span>
</code></pre></td></tr></table>
</div>
</div><p>故事并没有到此结束。 
对线程调用Wait方法（或者求Result）不是最好的办法，因为它会阻滞主线程，并且CLR在后台会新起线程池线程来完成额外的工作。如果要包装异常到主线程，另外一个方法就是使用事件通知的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice85</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">class</span> <span class="nc">AggregateExceptionArgs</span> <span class="p">:</span> <span class="n">EventArgs</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="n">AggregateException</span> <span class="n">AggregateException</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">event</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">AggregateExceptionArgs</span><span class="p">&gt;</span> <span class="n">AggregateExceptionCatched</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">AggregateExceptionCatched</span> <span class="p">+=</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">AggregateExceptionArgs</span><span class="p">&gt;(</span><span class="n">Program_AggregateExceptionCatched</span><span class="p">);</span>
            <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">try</span>
                <span class="p">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;任务并行编码时候产生的未知异常&#34;</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">err</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">AggregateExceptionArgs</span> <span class="n">errArgs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AggregateExceptionArgs</span> <span class="p">{</span> <span class="n">AggregateException</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AggregateException</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">};</span>
                    <span class="n">AggregateExceptionCatched</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">errArgs</span><span class="p">);</span>
                <span class="p">}</span>

            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程马上结束!&#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Action</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">program_AggregateExceptionCatched</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="n">Program_AggregateExceptionCatched</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">AggregateExceptionArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">e</span><span class="p">.</span><span class="n">AggregateException</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;ExceptionType: {0} {1} from {2} {3} Exception Content:{4}&#34;</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​		在这个实例中， 我们声明了一个委托<code>AggregateExceptionCatchHandler</code>，它接受两个参数，一个是事件的通知者；另一个是事件变量AggregateExceptionArgs。AggregateExceptionArgs是为了包装异常而新建的一个类型。</p>
<p>​		在主线程中，我们为事件AggregateExceptionCatched分配了事件处理方法Program_AggregateExceptionCatched，当任务Task捕获到异常时，代码引发事件。这种方式完全没有阻滞主线程。如果是在<code>Winform或WPF</code>窗体程序中，要在事件处理方法中处理UI界面，还可以将异常信息交给窗体的线程模型去处理。所以，<strong>最终建议大家采用事件通知的模型处理Task中的异常</strong>。</p>
<p><strong>注意</strong>　任务调度器<code>TaskScheduler</code>提供了这样一个功能，它有一个静态事件用于处理未捕获到的异常。一般不建议这样使用，因为事件回调是在进行垃圾回收的时候才发生的。如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice85</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">UnobservedTaskException</span> <span class="p">+=</span> <span class="k">new</span> <span class="n">EventHandler</span><span class="p">&lt;</span>
                <span class="n">UnobservedTaskExceptionEventArgs</span><span class="p">&gt;(</span><span class="n">TaskScheduler_UnobservedTaskException</span><span class="p">);</span>
            <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;任务并行编码中产生的未知异常&#34;</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
            <span class="n">t</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="n">GC</span><span class="p">.</span><span class="n">Collect</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>  
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程马上结束&#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="n">TaskScheduler_UnobservedTaskException</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span>
            <span class="n">UnobservedTaskExceptionEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">item</span> <span class="k">in</span> <span class="n">e</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;异常类型：{0}{1}来自：{2}{3}异常内容：{4}&#34;</span><span class="p">,</span>
                    <span class="n">item</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span>
                    <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">//将异常标识为已经观察到  
</span><span class="c1"></span>            <span class="n">e</span><span class="p">.</span><span class="n">SetObserved</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​		上面的这段代码运行的结果中并不会输出异常信息，因为发生异常的时刻，并没有发生垃圾回收（垃圾回收时机由CLR决定）。必须要将<code>GC.Collect(0)</code>的注释去掉，强制执行垃圾回收，才会观察到异常信息。这也正是此种方式的局限性。</p>
<h3 id="建议86parallel中的异常处理">建议86：<code>Parallel</code>中的异常处理</h3>
<p>​		上一个建议探讨了如何处理Task的异常， 由于Task的Start方法是异步启动的，因此需要额外的技术来完成异常的处理；Parallel相对来说会简单的多，因为Parallel的调用者线程会等到所有的任务全部完成后，再继续自己的工作；简而言之， 它具有同步的特性， 下面示例的代码就可以实现将并发异常包装到主线程中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Concurrent</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice86</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">parallelExceptions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="n">Exception</span><span class="p">&gt;();</span>
                <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span>
                <span class="p">{</span>
                    <span class="k">try</span>
                    <span class="p">{</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="n">InvalidOperationException</span><span class="p">(</span><span class="s">&#34;并行任务中的出现的异常&#34;</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span>
                    <span class="p">{</span>

                        <span class="n">parallelExceptions</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">parallelExceptions</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="n">AggregateException</span><span class="p">(</span><span class="n">parallelExceptions</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">});</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">err</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">foreach</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">item</span> <span class="k">in</span> <span class="n">err</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;异常类型：{0}{1}来自：{2}{3}异常内容：{4}&#34;</span><span class="p">,</span>
                    <span class="n">item</span><span class="p">.</span><span class="n">InnerException</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">InnerException</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span>
                    <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">InnerException</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;主线程马上结束!&#34;</span><span class="p">);</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在Parallel的异常处理中，使用了一个线程安全的泛型集合<code>ConcurrentQueue&lt;T&gt;</code>来处理并发中可能会遇到的集合线程安全性的问题；</p>
<h3 id="建议87区分wpf和winform的线程模型">建议87：区分WPF和WinForm的线程模型</h3>
<p>WPF和WinForm窗体应用程序都有一个要求，那就是UI元素（如<code>Button</code>、<code>TextBox</code>等）必须由创建它的那个线程进行更新。WinForm在这方面的限制并不是很严格，所以像下面这样的代码，在WinForm中大部分情况下还能运行（本建议后面会详细解释为什么会出现这种现象）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"> <span class="k">private</span> <span class="k">void</span> <span class="n">buttonStartAsync_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span>
 <span class="p">{</span>
     <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
         <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
     <span class="p">}</span>
<span class="p">});</span>
<span class="c1">//如果有异常，就启动一个新任务
</span><span class="c1"></span><span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">((</span><span class="n">task</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
    	<span class="n">task</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">inner</span> <span class="k">in</span> <span class="n">ex</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
        <span class="p">{</span>
        	<span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;异常类型：{0}{1}来自于：{2}{3}异常内容：{4}&#34;</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">Message</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span><span class="p">);</span>
<span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面这段代码如果放在WPF中，肯定会抛<code>System.InvalidOperationException</code>异常。</p>
<p>理论上，WinForm和WPF的线程模型非常接近，它们最后都是调用API（GetMessage或PeekMessage）来处理其他线程发送过来的消息，这些消息存储在系统的一个消息队列中。在WinForm和WPF中，创建主界面的线程就是主线程，也就是UI线程，UI线程负责处理该消息队列。只是两者在处理消息队列的上层机制上稍微有一些不同，这就造成了同样的代码得到不同的结果。</p>
<p>在WinForm框架中有一个<code>ISynchronizeInvoke</code>接口，所有的UI元素（表现为Control）都继承了该接口。其中，接口中的<code>InvokdRequired</code>属性表示了当前线程是否是创建它的线程。接口中的Invoke和<code>BeginInvoke</code>方法负责将消息发送到消息队列中，这样，UI线程就能够正确处理它了。那么，上面的这段代码在WinForm上的改进版本为（仅列出While循环部分）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">label1</span><span class="p">.</span><span class="n">InvokeRequired</span><span class="p">)</span>
    	<span class="n">label1</span><span class="p">.</span><span class="n">BeginInvoke</span><span class="p">(</span><span class="k">new</span> <span class="n">Action</span><span class="p">(()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
        	<span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
        <span class="p">}));</span>
    <span class="k">else</span>
    	<span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
    <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>BeginInvoke</code>方法接受的是一个Delegate类型的参数，在这里我们用一个Action来实现。</p>
<p>​		WPF应用程序的线程模型则完全依赖于<code>DispatcherObject</code>类型。所有的WPF控件都继承自一个抽象类Visual，而这个抽象类又最终继承自<code>DispatcherObject</code>类型。在这个<code>DispatcherObject</code>类型中有一个属性，两个方法。属性Dispatcher完成所有的工作线程和UI线程之间的调度任务。<code>CheckAccess</code>方法负责检测工作线程是否可以访问控件，如果是，则返回True；否则返回False。<code>VerifyAccess</code>方法则负责检测工作线程是否具有控件的访问权限，如果不能访问则抛出异常<code>InvalidOperationException</code>。</p>
<p>​		WinForm应用程序用类似<code>CheckAccess</code>的方式进行访问权限的判断；WPF应用程序则进行了改进，所有的UI控件都采用<code>VerifyAccess</code>的方式进行工作线程访问权限的判断。这直接决定了本建议开头处那个例子的输出，WPF只要判断出工作线程和UI线程不是同一个线程的，则直接抛出异常，而WinForm却有成功执行的余地。但是，WinForm的这种机制直接造成了程序的不稳定，因为即使在大部分情况下代码能很好的工作，可是在不确定的情况下，那样的代码中工作线程会直接操作UI元素，这样还是会抛出异常的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="c1">//用于表示主线程，在本例中就是UI线程
</span><span class="c1"></span><span class="n">Thread</span> <span class="n">mainThread</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">CheckAccess</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mainThread</span> <span class="p">==</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span> <span class="n">VerifyAccess</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">CheckAccess</span><span class="p">())</span>
    	<span class="k">throw</span> <span class="k">new</span> <span class="n">InvalidOperationException</span><span class="p">(</span><span class="s">&#34;调用线程无法访问此对象，因为另一个线程拥有此对象&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="n">buttonStartAsync_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//当前线程就是主线程
</span><span class="c1"></span>    <span class="n">mainThread</span> <span class="p">=</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">;</span>
    <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
    	<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    	<span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">CheckAccess</span><span class="p">())</span>
                <span class="n">label1</span><span class="p">.</span><span class="n">BeginInvoke</span><span class="p">(</span><span class="k">new</span> <span class="n">Action</span><span class="p">(()</span> <span class="p">=&gt;</span>
                <span class="p">{</span>
                    <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
                <span class="p">}));</span>
            <span class="k">else</span>
                <span class="n">label1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">});</span>
    <span class="c1">// 如果有异常，就启动一个新任务
</span><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">((</span><span class="n">task</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
        	<span class="n">task</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">inner</span> <span class="k">in</span> <span class="n">ex</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>
            <span class="p">{</span>
            	<span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;异常类型：{0}{1}来自于：{2}{3}异常内容：{4}&#34;</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">Message</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这段代码中， 模拟WPF中DispatcherObject的两个方法CheckAccess和VerifyAccess对线程模型进行了重新处理，增强了系统的稳定性。在实际工作中，我们也可以提取这两个方法为扩展方法，以便项目中的所有UI类型都能使用到。</p>
<p>WPF支持这两个方法，其全部代码如下所示（注意查看While循环部分）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">private</span> <span class="k">void</span> <span class="n">buttonStart_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">Task</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>  
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="k">this</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="n">BeginInvoke</span><span class="p">(</span><span class="k">new</span> <span class="n">Action</span><span class="p">(()</span> <span class="p">=&gt;</span>
                <span class="p">{</span>  
                    <span class="n">textBlock1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>  
                <span class="p">}));</span>  
            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">});</span>  
    <span class="c1">//为了捕获异常，启动了一个新任务  
</span><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">((</span><span class="n">task</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>  
        <span class="k">try</span>  
        <span class="p">{</span>  
            <span class="n">task</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>  
        <span class="p">}</span>  
        <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ex</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="k">foreach</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">inner</span> <span class="k">in</span> <span class="n">ex</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">)</span>  
            <span class="p">{</span>  
                <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&#34;异常类型：{0}{1}来自：{2}{3}异常内容：{4}&#34;</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">GetType</span><span class="p">(),</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span>  
                    <span class="n">inner</span><span class="p">.</span><span class="n">Source</span><span class="p">,</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">,</span> <span class="n">inner</span><span class="p">.</span><span class="n">Message</span><span class="p">));</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
    <span class="p">},</span> <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span><span class="p">);</span>  
    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p><strong>注意</strong>： 为了演示方便， 本建议中的异常没有传递到主线程；实际编码中，应该始终考虑将异常包装到主线程；</p>
<h3 id="建议88并行并不意味着速度更快">建议88：并行并不意味着速度更快</h3>
<p>并行所带来的后台任务以及任务的管理， 都会带来一定的开销，如果一项工作本来就能很快的完成，或者说其循环体就很小，那么如果采用并行可能会比非并行慢；</p>
<p>看下面的一个例子， 比较一下同步和并行状态下的时间消耗:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice88</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Stopwatch</span> <span class="n">watch</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stopwatch</span><span class="p">();</span>
            <span class="n">watch</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">DoInFor</span><span class="p">();</span>
            <span class="n">watch</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Sync Cost time:{0}&#34;</span><span class="p">,</span> <span class="n">watch</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">);</span>

            <span class="n">watch</span><span class="p">.</span><span class="n">Restart</span><span class="p">();</span>
            <span class="n">DoInParalleFor</span><span class="p">();</span>
            <span class="n">watch</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Parallel Cost time:{0}&#34;</span><span class="p">,</span> <span class="n">watch</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">);</span>

        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="n">DoSometing</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">i</span><span class="p">++;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="n">DoInFor</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">200</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">DoSometing</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="n">DoInParalleFor</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">200</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="n">DoSometing</span><span class="p">();</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个是在测试的四核PC机上的运行结果是：</p>
<p><img src="https://bomir.top/pics/CSharpAdvice/image-20211117102725712.png" alt="image-20211117102725712"></p>
<p>可见，同步只用了<code>0.1084ms,</code> 而并行用了7.8ms才完成工作；</p>
<p>现在，为了模拟让循环体做更多事情，将<code>DoSomething</code>方法中的循环体由10变为10000000。运行的结果为：</p>
<p><img src="https://bomir.top/pics/CSharpAdvice/image-20211117102849341.png" alt="image-20211117102849341"></p>
<p>当循环体需要做更多工作的时候，我们发现，同步需要3.77秒才能完成工作，而并行则仅使用1.03秒就完成了工作。</p>
<h3 id="建议89在并行方法体中谨慎使用锁">建议89：在并行方法体中谨慎使用锁</h3>
<p>​		除建议88里面提到的场合， 要谨慎使用并行的情况还包括：<strong>某些本身就需要同步运行的场合</strong>，或者<strong>需要较长时间锁定共享资源的场合</strong>；在对整型数据进行同步操作时，可以使用静态类<code>InterLocked</code>的Add方法，这就极大地避免了由于进行原子操作长时间锁定某个共享资源所带来的同步性能损耗。建议83的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice83</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span> <span class="p">};</span>
            <span class="kt">int</span> <span class="n">total</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="m">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> 
            <span class="p">{</span>
                <span class="k">return</span> <span class="m">1</span><span class="p">;</span>    
            <span class="p">},</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">loopState</span><span class="p">,</span> <span class="n">subtotal</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">subtotal</span> <span class="p">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">return</span> <span class="n">subtotal</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Interlocked</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">total</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;total={0}&#34;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>理论上，针对total的加法操作，需要使用一个同步锁，否则就无法避免一次torn read（即两次<code>mov</code>操作所导致的字段内存地址边界对齐问题）。FCL通过提供Interlocked类型解决了这个问题。FCL用来解决简单类型的原子性操作还提供了volatile关键字。不过这些都不是本建议所要讨论的重点。FCL现有的原子性操作为我们同步整型数据的时候，带来了性能上的提高。但是，在其他一些场合，我们却不得不考虑因为同步锁带来的损耗。</p>
<p>来看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice89</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SampleClass</span> <span class="n">sample</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SampleClass</span><span class="p">();</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10000000</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">sample</span><span class="p">.</span><span class="n">SimpleAdd</span><span class="p">();</span>
            <span class="p">});</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">sample</span><span class="p">.</span><span class="n">SomeCount</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">internal</span> <span class="k">class</span> <span class="nc">SampleClass</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">long</span> <span class="n">SomeCount</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="n">SimpleAdd</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">SomeCount</span><span class="p">++;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可能输出的一个结果是： <code>3318274</code>；</p>
<p><img src="https://bomir.top/pics/CSharpAdvice/image-20211117155055396.png" alt="image-20211117155055396"></p>
<p>显然， 这和我们期待输出的<code>10000000</code>有较大的差距。为了保证输出正确， 必须为并行中的方法体加锁（假设SampelClass是外部提供的API，无权进行源码修改在其内部加锁）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Advice89</span>
<span class="p">{</span>
    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SampleClass</span> <span class="n">sample</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SampleClass</span><span class="p">();</span>
            <span class="kt">object</span> <span class="n">syncObj</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
            <span class="n">Parallel</span><span class="p">.</span><span class="n">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10000000</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">lock</span> <span class="p">(</span><span class="n">syncObj</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">sample</span><span class="p">.</span><span class="n">SimpleAdd</span><span class="p">();</span>
                <span class="p">}</span>

            <span class="p">});</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">sample</span><span class="p">.</span><span class="n">SomeCount</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">internal</span> <span class="k">class</span> <span class="nc">SampleClass</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">long</span> <span class="n">SomeCount</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="n">SimpleAdd</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">SomeCount</span><span class="p">++;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​		加锁之后，代码的输出变正确了。但是，这段代码会带来其他的问题；由于锁的存在，系统的开销也增加了，同步带来的线程上下文切换，使我们牺牲了CPU时间与空间性能。简单来说，这段代码还不如不用并行，要确保锁定恰当的同步对象，锁其实就是让多线程变成单线程（因为同时只允许一个线程访问资源）。所以我们需要谨慎的对待并行方法中的同步问题。如果方法体的全部内容都需要同步运行，就完全不应该使用并行；</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">bomir</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2019-10-23
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://bomir.top/tags/csharp/">CSharp</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/csharp-others-talk/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">C#杂项聊一聊</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/basic-language-elements/">
            <span class="next-text nav-default">改善C#代码的157个建议（1）- 基本要素</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "Shaper-fox/hugoblogtalks"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:jinchunw@385@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/Bicomir" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://bomir.top/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>
  <span class="copyright-year">
    &copy;
    
      2017 -
    2021
    <span class="heart">
      
      <i class="iconfont">        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        bomir
        
      </span>
	  <span class="division">|</span>
	  <span class="author">
			<a href="http://beian.miit.gov.cn/">粤ICP备2021140392号-1</a>
	  </span></span>
  
  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
