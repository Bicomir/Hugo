<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>消息队列记录 - Wallis</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="bomir" />
  <meta name="description" content="消息队列的面试连环炮 前言 你用过消息队列么？ 说说你们项目里是怎么用消息队列的？ 我们有一个订单系统，订单系统会每次下一个新订单的时候，就会发送一" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.85.0" />


<link rel="canonical" href="https://bomir.top/post/message-queue-record/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="消息队列记录" />
<meta property="og:description" content="消息队列的面试连环炮 前言 你用过消息队列么？ 说说你们项目里是怎么用消息队列的？ 我们有一个订单系统，订单系统会每次下一个新订单的时候，就会发送一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bomir.top/post/message-queue-record/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-13T21:19:05+00:00" />
<meta property="article:modified_time" content="2020-11-13T21:19:05+00:00" />

<meta itemprop="name" content="消息队列记录">
<meta itemprop="description" content="消息队列的面试连环炮 前言 你用过消息队列么？ 说说你们项目里是怎么用消息队列的？ 我们有一个订单系统，订单系统会每次下一个新订单的时候，就会发送一"><meta itemprop="datePublished" content="2020-11-13T21:19:05+00:00" />
<meta itemprop="dateModified" content="2020-11-13T21:19:05+00:00" />
<meta itemprop="wordCount" content="11676">
<meta itemprop="keywords" content="消息队列," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="消息队列记录"/>
<meta name="twitter:description" content="消息队列的面试连环炮 前言 你用过消息队列么？ 说说你们项目里是怎么用消息队列的？ 我们有一个订单系统，订单系统会每次下一个新订单的时候，就会发送一"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">秤流沙</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/about/">关于我</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/Bicomir" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      秤流沙
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bomir.top/about/">关于我</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/Bicomir" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">消息队列记录</h1>
      
      <div class="post-meta">
        <time datetime="2020-11-13" class="post-time">
          2020-11-13
        </time>
        <div class="post-category">
            <a href="https://bomir.top/categories/messagequeue/"> MessageQueue </a>
            
          </div>
        <span class="more-meta"> 约 11676 字 </span>
          <span class="more-meta"> 预计阅读 24 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#为什么使用消息队列">为什么使用消息队列？</a>
      <ul>
        <li><a href="#剖析">剖析</a></li>
        <li><a href="#解答">解答</a></li>
        <li><a href="#解耦">解耦</a></li>
        <li><a href="#异步">异步</a></li>
        <li><a href="#削峰">削峰</a></li>
      </ul>
    </li>
    <li><a href="#消息队列有什么优点和缺点">消息队列有什么优点和缺点？</a></li>
    <li><a href="#有什么区别以及适用场景">有什么区别，以及适用场景？</a></li>
    <li><a href="#如何保证消息队列的高可用">如何保证消息队列的高可用？</a>
      <ul>
        <li><a href="#剖析-1">剖析</a></li>
        <li><a href="#rabbitmq高可用性">RabbitMQ高可用性</a></li>
        <li><a href="#kafka实现高可用">kafka实现高可用</a></li>
      </ul>
    </li>
    <li><a href="#如果保证消息的重复消费">如果保证消息的重复消费？</a>
      <ul>
        <li><a href="#剖析-2">剖析</a></li>
        <li><a href="#幂等性是什么">幂等性是什么？</a></li>
      </ul>
    </li>
    <li><a href="#怎么保证消息队列消费的幂等性">怎么保证消息队列消费的幂等性？</a>
      <ul>
        <li><a href="#解决思路">解决思路</a></li>
      </ul>
    </li>
    <li><a href="#如何保证消息传输不丢失">如何保证消息传输不丢失？</a>
      <ul>
        <li><a href="#剖析-3">剖析</a></li>
        <li><a href="#为什么会丢数据">为什么会丢数据</a></li>
      </ul>
    </li>
    <li><a href="#如何保证消息的顺序性">如何保证消息的顺序性？</a>
      <ul>
        <li><a href="#场景">场景</a></li>
        <li><a href="#rabbitmq保证消息顺序性">RabbitMQ保证消息顺序性</a></li>
        <li><a href="#kafka保证消息消息顺序性">Kafka保证消息消息顺序性</a></li>
      </ul>
    </li>
    <li><a href="#百万消息积压在队列中如何处理">百万消息积压在队列中如何处理？</a>
      <ul>
        <li><a href="#剖析-4">剖析</a></li>
        <li><a href="#场景1积压大量消息">场景1：积压大量消息</a></li>
        <li><a href="#场景2大量消息积压并且设置了过期时间">场景2：大量消息积压，并且设置了过期时间</a></li>
        <li><a href="#场景3大量消息积压导致mq磁盘满了">场景3：大量消息积压，导致MQ磁盘满了</a></li>
      </ul>
    </li>
    <li><a href="#如何设计一个消息中间件架构">如何设计一个消息中间件架构？</a>
      <ul>
        <li><a href="#思路">思路</a></li>
      </ul>
    </li>
    <li><a href="#消息队列相关问题总结">消息队列相关问题总结</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="消息队列的面试连环炮">消息队列的面试连环炮</h1>
<h2 id="前言">前言</h2>
<ul>
<li>你用过消息队列么？</li>
<li>说说你们项目里是怎么用消息队列的？
<ul>
<li>我们有一个订单系统，订单系统会每次下一个新订单的时候，就会发送一条消息到ActiveMQ里面去，后台有一个库存系统，负责获取消息，然后更新库存。</li>
</ul>
</li>
<li>为什么使用消息队列？
<ul>
<li>你的订单系统不发送消息到MQ，而是直接调用库存系统的一个接口，然后直接调用成功了，库存也更新了，那就不需要使用消息队列了呀</li>
<li>使用消息队列的主要作用是：<strong>异步</strong>、<strong>解耦</strong>、<strong>削峰</strong></li>
</ul>
</li>
<li>消息队列都有什么优缺点？</li>
<li>Kafka、activeMQ、RibbitMQ、RocketMQ都有什么优缺点？</li>
<li>如何保证消息队列的高可用？</li>
<li>如何保证消息不被重复消费？如何保证消息消费时的幂等性？</li>
<li>如何保证消息的可靠性传输，要是消息丢失了怎么办？</li>
<li>如何保证消息的顺序性？</li>
<li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</li>
<li>如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？</li>
</ul>
<p>面试官问的问题不是发散的，而是从点、铺开，比如先聊一聊高并发的话题，就这个话题里面继续聊聊缓存、MQ等等东西。对于每个小话题，比如说MQ，就会从浅入深。</p>
<h2 id="为什么使用消息队列">为什么使用消息队列？</h2>
<h3 id="剖析">剖析</h3>
<p>首先明白为什么系统中要使用到消息队列这种东西？</p>
<p>因为之前面试的大量候选人，说自己项目中使用了Redis，MQ，但是其实他们并不清楚为什么要用这个东西，说白了就是为了用而用，或者是别人设计的架构，从头到尾就没有思考过。</p>
<p>没有对自己的架构问过为什么的人，一定是平时没有思考的人，面试官对这类候选人印象通常不好。</p>
<h3 id="解答">解答</h3>
<p>其实就是问问你消息队列有哪些场景，然后你项目里面的具体是什么场景，说说你在这个场景里用什么消息队列是什么？</p>
<p>消息队列的场景使用场景很多，主要是三个：解耦、异步、和削峰</p>
<h3 id="解耦">解耦</h3>
<h4 id="不使用mq时">不使用MQ时</h4>
<p>A系统发送数据到B、C、D系统，但没有使用消息队列时候的耦合场景</p>
<p><a href="https://imgtu.com/i/WzIX4J"><img src="https://z3.ax1x.com/2021/08/01/WzIX4J.png" alt="WzIX4J.png"></a></p>
<p>当后面系统不断增加，比如 E，F系统的加入，以及D系统的移除</p>
<p><a href="https://imgtu.com/i/WzIzg1"><img src="https://z3.ax1x.com/2021/08/01/WzIzg1.png" alt="WzIzg1.png"></a></p>
<p>因为A系统和其它各种系统耦合起来，那么需要处理的事情会给出多</p>
<h4 id="使用mq后">使用MQ后</h4>
<p>系统A发送一条消息，到消息队列中，哪个系统需要获取到哪里，那么从MQ中消费数据，如果新系统E加入的话，那么只需要编写代码，然后也直接从MQ中消费即可，当系统D不需要这个数据时，那么只需要不对该消息进行消费即可。系统A不需要考虑给谁发送数据，也不需要维护这个代码，不需要考虑人家是否调用成功、失败、超时等等情况</p>
<p><a href="https://imgtu.com/i/WzIvC9"><img src="https://z3.ax1x.com/2021/08/01/WzIvC9.png" alt="WzIvC9.png"></a></p>
<p>总结：通过一个MQ，发布和订阅模型，Pub/Sub模型，系统A就和其它系统彻底解耦。</p>
<p>需要考虑一下负责的系统中，是否有类似的场景，就是一个系统或者一个模块，调用了多个系统，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要同步调用接口的，如果用MQ给他异步化解耦，也是可以的，这个时候可以考虑在自己的项目中，是不是可以运用这个MQ来进行系统的解耦。</p>
<h3 id="异步">异步</h3>
<h4 id="不用mq的同步高延时请求场景">不用MQ的同步高延时请求场景</h4>
<p>下面的一个场景就是系统A，调用了其它三个系统的服务，我们发现用户在执行一个请求后，需要花费很长的时间</p>
<p><img src="https://bomir.top/pics/images/image-20200419205855859.png" alt="image-20200419205855859"></p>
<p>我们发现，用户执行一个接口，就需要花费350毫秒，假设我们将每个接口的耗时增加，可能会将近花费1秒，这个时候一般用户几乎不能接受，因为一般互联网类的企业，对用户的直接操作，一般要求是每个请求都必须在200ms以内完成，因为这个是对用户是无感知的</p>
<h4 id="使用mq进行异步化">使用MQ进行异步化</h4>
<p><img src="https://bomir.top/pics/images/image-20200419213232855.png" alt="image-20200419213232855"></p>
<p>系统A只需要发送消息到MQ中就直接返回了，然后其它系统各自在MQ中进行消费。用户在执行系统A的时候，就会感觉非常快就得到响应了。</p>
<h3 id="削峰">削峰</h3>
<h4 id="没有用mq的削峰">没有用MQ的削峰</h4>
<p><img src="https://bomir.top/pics/images/image-20200419213609511.png" alt="image-20200419213609511"></p>
<p>一般的MySQL，抗到QPS=2000的时候就已经达到了瓶颈，如果每秒请求达到了5000的话，可能直接就把MySQL打死了。如果MySQL被打死，然后整个系统就崩溃，然后系统就没法使用。</p>
<p>但是中午的高峰期过了之后，到下午的时候，就成了低峰期，可能也就一万用户同时在网站上操作，每秒的请求数量可能就50个请求，对整个系统几乎没有任何压力。</p>
<h4 id="使用mq来进行削峰">使用MQ来进行削峰</h4>
<p><img src="https://bomir.top/pics/images/image-20200419235201993.png" alt="image-20200419235201993"></p>
<p>削峰就是大量的请求过来，然后MQ将其消化掉了，然后通过其它系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。</p>
<h2 id="消息队列有什么优点和缺点">消息队列有什么优点和缺点？</h2>
<p>优点上面已经说了：解耦、异步、削峰，缺点呢？显而易见的</p>
<ul>
<li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统接口就好了，人家ABCD四个系统好好的，没啥问题，这个时候却加入了MQ进来，万一MQ挂了怎么办？MQ挂了整套系统也会崩溃了。</li>
<li>系统复杂性提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li>
<li>一致性问题：A系统处理完了直接返回成功了，人都以为你的请求成功了，但是问题是，要在BCD三个系统中，BD两个系统写库成功了，结果C系统写库失败了，这样就会存在数据不一致的问题。</li>
<li>所以说消息队列实际上是一种复杂的架构，你引入它有好多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最后发现系统复杂性提升了一个数量级，也许是复杂10倍，但是关键时刻，用还是得用。</li>
</ul>
<p><img src="https://bomir.top/pics/images/image-20200420070841754.png" alt="image-20200420070841754"></p>
<h2 id="有什么区别以及适用场景">有什么区别，以及适用场景？</h2>
<p>主流MQ包括：kafka、ActiveMQ、RabbitMQ和RocketMQ</p>
<p>常见的MQ其实就上面的四种</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机吞吐量</td>
<td>万级，吞吐量比RocketMQ和Kafka要低一个数量级</td>
<td>万级，吞吐量比RocketMQ和Kafka要低一个数量级</td>
<td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td>
<td>10万级1这是kafka最大的优点，就是吞吐量高。一般配置和数据类的系统进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>时效性</td>
<td>ms级</td>
<td>微妙级，这是RabbitMQ的一大特点，就是延迟最低</td>
<td>ms级</td>
<td>延迟在ms级内</td>
</tr>
<tr>
<td>可用性</td>
<td>基于主从架构实现高可用</td>
<td>高，基于主从架构实现高可用</td>
<td>非常高，分布式架构</td>
<td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机后，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>消息不丢失</td>
<td>经过参数优化配置，可以做到0丢失</td>
<td>经过参数优化配置可以做到0丢失</td>
</tr>
<tr>
<td>核心特点</td>
<td>MQ领域的功能及其完备</td>
<td>基于Erlang开发，所以并发能力强，性能及其好，延时很低</td>
<td>MQ功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是实时上的标准。</td>
</tr>
<tr>
<td></td>
<td>非常成熟，功能强大，在业内大量公司以及项目都有应用。  但是偶尔消息丢失的概率，并且现在社区以及国内应用都越来越少，官方社区对ActiveMQ5.X维护越来越少，而且确实主要是基于解耦和异步来用的，较少在大规模吞吐场景中使用</td>
<td><strong>erlang语言开发的，性能及其好，延时很低</strong>。而且开源的版本，就提供的<strong>管理界面非常棒</strong>，在国内一些互联网公司近几年用RabbitMQ也是比较多一些，特别适用于中小型的公司 缺点显而易见，就是吞吐量会低一些，这是因为它做的实现机制比较中，因为使用erlang开发，目前没有多少公司使用其开发。所以针对源码界别的定制，非常困难，因此公司的掌控非常弱，只能依赖于开源社区的维护。</td>
<td>接口简单易用，毕竟在阿里大规模应用过，有阿里平台保障，日处理消息上 百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是OK的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。</td>
<td>仅仅提供较少的核心功能，但是提供<strong>超高的吞吐量</strong>，ms级别的延迟，极高的可用性以及可靠性，分布式可以任意扩展。    同时kafka最好是支撑较少的topic数量即可，保证其超高的吞吐量。天然的适合大数据实时计算以及日志收集。</td>
</tr>
</tbody>
</table>
<p>综上所述：</p>
<ul>
<li>一般的业务要引入MQ，最早大家都是用ActviceMQ，但是现在大家用的不多了，没有经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了，不太图鉴使用</li>
<li>RabbitMQ后面被大量的中小型公司所使用，但是erlang语言阻碍了大量的Java工程师深入研究和掌握它，对公司而言，几乎处于不可控的状态，但是RabbitMQ目前开源稳定，活跃度也表较高。</li>
<li>RocketMQ是阿里开源的一套消息中间件，目前也已经经历了天猫双十一，同时底层使用Java进行开发</li>
</ul>
<p>如果中小型企业技术实力一般，技术挑战不是很高，用RabbitMQ是个不错的选择。如果公司的基础研发能力很强，想精确到源码级别的掌握，那么推荐使用RocketMQ。同时如果项目是聚焦于大数据领域的实时计算，日志采集等场景，那么Kafka是业内标准， kafka社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>
<h2 id="如何保证消息队列的高可用">如何保证消息队列的高可用？</h2>
<h3 id="剖析-1">剖析</h3>
<p>这个问题用的很好，不会具体到某个MQ，而是问一个整体，然后通过你使用的MQ，来具体谈谈该MQ的可用性的理解。</p>
<h3 id="rabbitmq高可用性">RabbitMQ高可用性</h3>
<p>RabbitMQ是比较有代表性的，因为是基于主从做高可用性的。</p>
<p>RabbitMQ 三种模式：单机模式，普通集群模式，镜像集群模式</p>
<h4 id="单机模式">单机模式</h4>
<p>就是demo级别的，一般就是本地启动后玩一玩，没有人生产环境中使用。</p>
<h4 id="普通集群模式">普通集群模式</h4>
<ul>
<li>意思就是在多台机器上启动多个RabbitMQ实例，每台机器启动一个，但是创建的Queue，只会放在一个RabbitMQ实例上，但是每个实例都同步queue元数据，在消费的时候，实际上是连接到另外一个实例上，那么这个实例会从queue所在实例上拉取数据过来，这种方式确实很麻烦，也不怎么好，没做到所谓的分布式 ，就是个普通集群。因为这导致你要么消费每次随机连接一个实例，然后拉取数据，要么固定连接那个queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</li>
<li>而且如果那个放queue的实例宕机了，会导致接下来其它实例无法从那个实例拉取，如果 你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，得等到这个实例恢复了，然后才可以继续从这个queue拉取数据。</li>
</ul>
<p><img src="https://bomir.top/pics/images/image-20200420091806944.png" alt="image-20200420091806944"></p>
<p>这里没有什么所谓的高可用性可言，这个方案主要就是为了解决吐吞量，就是集群中的多个节点来服务于某个queue的读写操作。</p>
<p>存在两个缺点</p>
<ul>
<li>可能会在RabbitMQ中存在大量的数据传输</li>
<li>可用性没有什么保障，如果queue所在的节点宕机，就会导致queue的消息丢失</li>
</ul>
<h4 id="镜像集群模式">镜像集群模式</h4>
<p>这种模式，才是RabbitMQ的高可用模式，和普通的集群模式不一样的是，你创建的queue无论元数据还是queue里的消息都会存在与多个实例中，然后每次你写消息到queu的时候，都会自动把消息推送到多个实例的queue中进行消息同步。</p>
<p>这样的好处在于，任何一个机器宕机了，别的机器都可以用。坏处在于，性能开销提升，消息同步所有的机器，导致网络带宽压力和消耗增加，第二就是没有什么扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue</p>
<p>那么如何开启集群镜像策略呢？就是在RabbitMQ的管理控制台，新增一个策略，这个策略就是镜像集群模式下的策略，指定的时候，可以要求数据同步到所有的节点，也可以要求就 同步到指定数量的节点，然后再次创建queue的时候，应用这个策略，就会自动将数据同步到其它节点上去了。</p>
<p><img src="https://bomir.top/pics/images/image-20200420102752707.png" alt="image-20200420102752707"></p>
<p>集群镜像模式下，任何一个节点宕机了都是没问题的，因为其他节点还包含了这个queue的完整的数据，别的consumer可以到其它活着的节点上消费数据。</p>
<p>但是这个模式还存在问题：就是不是分布式的，如果这个queue的数据量很大，大到这个机器上的容量无法容纳的时候，此时应该怎么办呢？</p>
<h3 id="kafka实现高可用">kafka实现高可用</h3>
<p><img src="https://bomir.top/pics/images/image-20200420104251328.png" alt="image-20200420104251328"></p>
<p>kafka一个最基本的架构认识：多个broker组件，每个broker是一个节点，你创建一个topic，这个topic可以划分成多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。</p>
<p>这就是天然的分布式消息队列，就是说一个topic的数据，是分散在多个机器上的，每个机器上就放一部分数据。</p>
<p>实际上RabbitMQ之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩，RabbitMQ一个queue的数据都放在一个节点里了，镜像集群下，也是每个节点都放这个queu的完整数据。</p>
<p>kafka0.8以前，是没有HA机制（replicate副本机制）的，就是任何一个broker宕机了，那个broker上的partition就废了，没法读也没办法写，没有什么高可用可言，而在0.8版本后，提供了HA机制，就是replica副本机制，每个partition的数据都会同步到其它机器上，形成自己的多个replica副本，然后所有的replica就是follower，写的时候，leader会负责数据都同步到所有的follower上，读的时候就直接读取leader上的数据即可。只能读写leader？很简单，要是你能随意读写每个follower，那么就需要保证数据一致性的问题，系统复杂度太高，很容易出问题，kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才能够提高容错性</p>
<p>每个副本不会存储节点的全部数据，而是数据可能分布在不同的机器上。</p>
<p><img src="https://bomir.top/pics/images/image-20200420105712380.png" alt="image-20200420105712380"></p>
<p>同时多个副本中，会选取一个作为leader，其它的副本是作为follower，并且只有leader能对外提供读写，同时leader在写入数据后，它还会把全部的数据同步到follower中，保证数据的备份。</p>
<p>此时，高可用的架构就出来了，假设现在某个机器宕机了，比如其中的一个leader宕机了，但是因为每个leader下还有多个follower，并且每个follower都进行了数据的备份，因此kafka会自动感知leader已经宕机，同时将其它的follower给选举出来，作为新的leader，并向外提供服务支持。</p>
<h2 id="如果保证消息的重复消费">如果保证消息的重复消费？</h2>
<p>面试题：如何保证消息的重复消费？如何保证消息消费的幂等性？（一个问题）</p>
<h3 id="剖析-2">剖析</h3>
<p>其实这是一个常见的问题，既然是消费消息，那肯定是要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？关于消息重复消费的问题，其实本质上就是问你使用消息队列如何保证幂等性，这个是你架构中要考虑的问题。</p>
<p>首先是比尔RabbitMQ、RocketMQ、Kafka都会出现消息重复消费的问题，因为这个问题通常不是MQ自己保证的，而是保证消息的不丢失，我们首先从Kafka上来说：</p>
<p>kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我从上次消费到的offset来继续消费。</p>
<p>但是凡事总有例外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启，如果碰到着急的，直接kill杀死进程，然后重启，这就会导致consumer有些消息处理了没来得及提交offset，然后重启后，就会造成少数消息重复消费的问题。</p>
<p>重复消费不可怕，重要的是有没有考虑过重复消费之后，怎么保证幂等性？</p>
<p>例如：有个系统，消费一条数据往数据库插入一条，要是消息重复消费了两次，那么就插入两条数据了，这个数据也就出错了。</p>
<p><img src="https://bomir.top/pics/images/image-20200420112217458.png" alt="image-20200420112217458"></p>
<p>消费者如果在准备提交offset，但是还没有提交的时候，消费者进程被重启，那么此时已经消费过数据的offset并没有提交，kafka也就不知道你已经消费了，那么消费者再次上线进行消费的时候，会把已经消费的数据，重新在传递过来，这就是消息重复消费的问题。</p>
<h3 id="幂等性是什么">幂等性是什么？</h3>
<p>通俗点说：幂等性就是一个数据，或者一个请求，给你执行多次，得保证对应的数据不会改变，并且不能出错，这就是幂等性。</p>
<h2 id="怎么保证消息队列消费的幂等性">怎么保证消息队列消费的幂等性？</h2>
<p>一条数据重复出现两次，但是数据库里只有一条数据，这就保证了系统的幂等性。</p>
<h3 id="解决思路">解决思路</h3>
<ul>
<li>比如那个数据要写库，首先根据主键查一下，如果这个数据已经有了，那就别插入了，执行update即可</li>
<li>如果用的是redis，那就没问题了，因为每次都是set操作，天然的幂等性</li>
<li>如果不是上面的两个场景，那就做的稍微复杂一点，需要让生产者发送每条消息的时候，需要加一个全局唯一的id，类似于订单id之后的东西，然后你这里消费到了之后，先根据这个id去redis中查找，之前消费过了么，如果没有消费过，那就进行处理，然后把这个id写入到redis中，如果消费过了，那就别处理了，保证别重复消费相同的消息即可。</li>
<li>还有比如基于数据库唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会重复，因为Kafka消费者还没来得及提交offset，重复数据拿到了以后，我们进行插入的时候，因为有了唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据。</li>
</ul>
<p><img src="https://bomir.top/pics/images/image-20200420113844967.png" alt="image-20200420113844967"></p>
<h2 id="如何保证消息传输不丢失">如何保证消息传输不丢失？</h2>
<p>面试题：如何保证消息的可靠性传输（如何处理消息丢失的问题）？</p>
<h3 id="剖析-3">剖析</h3>
<p>消息队列有三个重要原则：消息不能多，不能少</p>
<p>不能多，指的就是刚刚提到的重复消费和幂等性问题，不能少，指的是数据在传输过程中，不会丢失。</p>
<p>如果说使用MQ用来传递非常核心的消息，比如说计费，扣费的一些消息，比如设计和研发一套核心的广告平台，计费系统是一个很重的业务，操作是很耗时的，所以说广告系统整体的架构里面，实际是将计费做成异步化的，然后中间就是加了一个MQ。例如在广告主投放了一个广告，约定的是每次用户点击一次就扣费一次，结果是用户动不动就点击了一次，扣费的时候搞的消息丢了，公司就会不断的少几块钱。这样积少成多，这就是造成了公司的巨大损失。</p>
<h3 id="为什么会丢数据">为什么会丢数据</h3>
<p>丢数据，一般分为两种，要么是MQ自己弄丢了，要么是我们消费的时候弄丢了。我们可以从RabbitMQ和Kafka分别来进行分析。</p>
<p>RabbitMQ一般来说都是承载公司的核心业务的，数据是绝对不能弄丢的。</p>
<p><img src="https://bomir.top/pics/images/image-20200420120701475.png" alt="image-20200420120701475"></p>
<h4 id="生产者丢失数据">生产者丢失数据</h4>
<p>生产者将数据发送到RabbitMQ的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。</p>
<p>此时选择用RabbitMQ提供的事务功能，就是生产者发送数据之前，开启RabbitMQ事务（channel.txSelect），然后发送消息，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，那么可以提交事务，但是问题是，RabbitMQ事务机制一搞，基本上吞吐量会下来，因为太损耗性能。</p>
<p><img src="https://bomir.top/pics/images/image-20200420121835297.png" alt="image-20200420121835297"></p>
<p>所以一般来说，如果你要确保写RabbitMQ消息别丢，可以开启confirm模式，在生产者那里设置了开启confirm模式之后，RabbitMQ会给你回传一个ack消息，告诉你这个消息OK了，如果RabbitMQ没能处理这个消息，会给你回调一个接口，告诉你这个消息接收失败，你可以重试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 开启事务
</span><span class="c1"></span><span class="k">try</span> <span class="o">{</span>
 <span class="c1">// 发送消息
</span><span class="c1"></span><span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// 重试发送消息
</span><span class="c1"></span><span class="o">}</span>
<span class="c1">//  提交
</span></code></pre></td></tr></table>
</div>
</div><p>但是，因为事务机制，是同步的；</p>
<p>针对于上述事务造成性能下降的问题，下面的方法是开启confirm模式</p>
<ul>
<li>
<p>首先把channel设置成confirm模式</p>
</li>
<li>
<p>然后发送一个消息</p>
</li>
<li>
<p>发送完消息之后，就不用管了</p>
</li>
<li>
<p>RabbitMQ如果接收到这个消息的话，就会回调你生产者本地的一个接口，通知你说这条消息我们已经收到了</p>
</li>
<li>
<p>RabbitMQ如果在接收消息的时候出错了，就会回调这个接口</p>
</li>
</ul>
<p>一般生产者如果要保证消息不丢失，一般是用confirm机制，因为是异步的模式，(非阻塞异步)在发送消息之后，不会阻塞，直接可以发送下一条消息，这样吞吐量会更高一些。</p>
<h4 id="rabbitmq丢失数据">RabbitMQ丢失数据</h4>
<p>这个就是RabbitMQ自己丢失数据，这个时候就必须开启RabbitMQ的持久化，就是消息写入之后，同时需要持久化到磁盘中，哪怕是RabbitMQ自己宕机了，也能够从磁盘中读取之前存储的消息，这样数据一般就不会丢失了，但是存在一个极端的情况，就是RabbitMQ还没持久化的时候，就已经宕机了，那么可能会造成少量的数据丢失，但是这个概率是比较小的。</p>
<p>设置持久化的两个步骤，第一个是创建queue的时候，将其持久化的，这样就保证了RabbitMQ持久化queue的元数据，但是不会持久化queue中的数据，第二个就是发送消息的时候，将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ将会将消息持久化到磁盘上，必须同时设置两个持久化才行，哪怕是Rabbit挂了，也会从磁盘中恢复queue 和 queue中的数据。</p>
<p>而且持久化可以跟生产者那边的confirm机制配置起来，只有消息被持久化到磁盘后，才会通知生产者ACK了，所以哪怕是在持久化磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到ACK，你也是可以自己重发的。</p>
<h4 id="消费者丢失数据">消费者丢失数据</h4>
<p>消费者丢失数据，主要是因为打开了AutoAck的机制，消费者会自动通知RabbitMQ，表明自己已经消费完这条数据了，但是如果你消费到了一条消息，还在处理中，还没处理完，此时消费者就会自动AutoAck了，通知RabbitMQ说这条消息已经被消费了，此时不巧的是，消费者系统宕机了，这条消息就会丢失，因为RabbitMQ以为这条消息已经处理掉。</p>
<p>在消费者层面上，我们需要将AutoAck给关闭，然后每次自己确定已经处理完了一条消息后，你再发送ack给RabbitMQ，如果你还没处理完就宕机了，此时RabbitMQ没收到你发的Ack消息，然后RabbitMQ就会将这条消息分配给其它的消费者去处理。</p>
<p><a href="https://imgtu.com/i/fSEgNF"><img src="https://z3.ax1x.com/2021/08/01/fSEgNF.png" alt="fSEgNF.png"></a></p>
<p>如果按照上述思路设置了ack=all, 一定不会丢， 要求是， 你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会不断的重试，重试无限次；</p>
<h2 id="如何保证消息的顺序性">如何保证消息的顺序性？</h2>
<h3 id="场景">场景</h3>
<p>以前做过一个MySQL binlog同步系统，压力还是非常大的，日同步数据要达到上亿。常见一点的在于 大数据项目中，就需要同步一个mysql库过来，然后对公司业务的系统做各种的复杂操作。</p>
<p>在mysql里增删改一条数据，对应出来的增删改3条binlog，接着这三条binlog发送到MQ里面，到消费出来依次执行，这个时候起码得保证能够顺序执行，不然本来是：增加、修改、删除，然后被换成了：删除、修改、增加，不全错了呢。</p>
<p>本来这个数据同步过来，应该是最后删除的，结果因为顺序搞错了，最后这个数据被保留了下来，数据同步就出错</p>
<ul>
<li>RabbitMQ：一个queue，多个consumer，这不明显乱了</li>
<li>Kafka：一个topic，一个partition，一个consumer，内部多线程，就会乱套</li>
</ul>
<p>在消息队列中，一个queue中的数据，一次只会被一个消费者消费掉</p>
<p><img src="https://bomir.top/pics/images/image-20200420150800480.png" alt="image-20200420150800480"></p>
<p>但因为不同消费者的执行速度不一致，在存入数据库后，造成顺序不一致的问题</p>
<p><img src="https://bomir.top/pics/images/image-20200420150935355.png" alt="image-20200420150935355"></p>
<h3 id="rabbitmq保证消息顺序性">RabbitMQ保证消息顺序性</h3>
<p>RabbitMQ：拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦，或者就是一个queue，但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。</p>
<p>下图为：一个consumer 对应 一个 queue，这样就保证了消息消费的顺序性。</p>
<p><img src="https://bomir.top/pics/images/image-20200420151354856.png" alt="image-20200420151354856"></p>
<h3 id="kafka保证消息消息顺序性">Kafka保证消息消息顺序性</h3>
<p>一个topic，一个partition，一个consumer，内部单线程消费，写N个内存，然后N个线程分别消费一个内存queue即可。注意，kafka中，写入一个partition中的数据，一定是有顺序的，</p>
<p><img src="https://bomir.top/pics/images/image-20200420152349066.png" alt="image-20200420152349066"></p>
<p>但是在一个消费者的内部，假设有多个线程并发的进行数据的消费，那么这个消息又会乱掉</p>
<p><img src="https://bomir.top/pics/images/image-20200420152542344.png" alt="image-20200420152542344"></p>
<p>这样时候，我们需要引入内存队列，然后我们通过消息的key，然后我们通过hash算法，进行hash分发，将相同订单key的散列到我们的同一个内存队列中，然后每一个线程从这个Queue中拉数据，同一个内存Queue也是有顺序的。</p>
<p><img src="images/image-20200420153622880.png" alt="image-20200420153622880"></p>
<h2 id="百万消息积压在队列中如何处理">百万消息积压在队列中如何处理？</h2>
<p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有百万消息积压接小时，说说解决思路？</p>
<h3 id="剖析-4">剖析</h3>
<p>MQ大幅度积压这件事挺常见的，一般不出，出了的话就是大型生产事故，例如：消费端每次消费之后要写MySQL，结果MySQL挂了，消费端就不动了，或者一直出错，导致消息消费速度极其慢。</p>
<h3 id="场景1积压大量消息">场景1：积压大量消息</h3>
<p>几千万的消息积压在MQ中七八个小时，这也是一个真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复consumer，让他恢复消费速度，然后傻傻的等待几个小时消费完毕，但是很显然这是一种比较不机智的做法。</p>
<p>假设1个消费者1秒消费1000条，1秒3个消费者能消费3000条，一分钟就是18万条，1000万条也需要花费1小时才能够把消息处理掉，这个时候在设备允许的情况下，如何才能够快速处理积压的消息呢？</p>
<p>一般这个时候，只能够做紧急的扩容操作了，具体操作步骤和思路如下所示：</p>
<ul>
<li>先修复consumer的问题，确保其恢复消费速度，然后将现有consumer都停止</li>
<li>临时建立好原先10倍或者20倍的queue数量</li>
<li>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue</li>
<li>接着临时征用10倍机器来部署consumer，每一批consumer消费一个临时queue的数据</li>
<li>这种做法相当于临时将queue资源和consumer资源扩大了10倍，以正常的10倍速度</li>
</ul>
<p><img src="https://bomir.top/pics/images/image-20200420160304030.png" alt="image-20200420160304030"></p>
<p>也就是让消费者把消息，重新写入MQ中，然后在用 10倍的消费者来进行消费。</p>
<p><img src="https://bomir.top/pics/images/image-20200420160319662.png" alt="image-20200420160319662"></p>
<h3 id="场景2大量消息积压并且设置了过期时间">场景2：大量消息积压，并且设置了过期时间</h3>
<p>假设你用的是RabbitMQ，RabbitMQ是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间，就会被RabbitMQ给清理掉，这个数据就没了。这个时候就不是数据被大量积压的问题，而是大量的数据被直接搞丢了。</p>
<p>这种情况下，就不是说要增加consumer消费积压的消息，因为实际上没有啥积压的，而是丢了大量的消息，我们可以采取的一个方案就是，批量重导，这个之前线上也有遇到类似的场景，就是大量的消息积压的时候，然后就直接丢弃了数据，然后等高峰期过了之后，例如在晚上12点以后，就开始写程序，将丢失的那批数据，写个临时程序，一点点查询出来，然后重新 添加MQ里面，把白天丢的数据，全部补回来。</p>
<p>假设1万个订单积压在MQ里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单查询出来，然后手动发到MQ里面去再补一次。</p>
<h3 id="场景3大量消息积压导致mq磁盘满了">场景3：大量消息积压，导致MQ磁盘满了</h3>
<p>如果走的方式是消息积压在MQ里，那么如果你很长时间都没有处理掉，此时导致MQ都快写满了，咋办？</p>
<p>这个时候，也是因为方案一执行的太慢了，只能写一个临时程序，接入数据来消费，然后消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到凌晨的时候，在把消息填入MQ中进行消费。</p>
<h2 id="如何设计一个消息中间件架构">如何设计一个消息中间件架构？</h2>
<p>如果让你写一个消息队列，该如何进行架构设计？说下你的思路</p>
<p>这种问题，说白了，起码不求你看过那些技术的源码，但是你应该大概知道那些技术的基本原理，核心组成部分，基本架构个构成，然后参照一些开源技术把一个系统设计出来的思路说一下就好了。</p>
<h3 id="思路">思路</h3>
<ul>
<li>首先MQ得支持可伸缩性，那就需要快速扩容，就可以增加吞吐量和容量，可以设计一个分布式的系统，参考kafka的设计理念，broker - &gt; topic -&gt; partition，每个partition放一台机器，那就存一部分数据，如果现在资源不够了，可以给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多的数据，提高更高的吞吐量。</li>
<li>其次得考虑一下这个MQ的数据要不要落地磁盘？也就是需不需要保证消息持久化，因为这样可以保证数据的不丢失，那落地盘的时候怎么落？顺序写，这样没有磁盘随机读写的寻址开销，磁盘顺序读的性能是很高的，这就是kafka的思路。</li>
<li>其次需要考虑MQ的可用性？这个可以具体到我们上面提到的消息队列保证高可用，提出了多副本 ，leader 和follower模式，当一个leader宕机的时候，马上选取一个follower作为新的leader对外提供服务。</li>
<li>需不需要支持数据0丢失？可以参考kafka零丢失方案</li>
</ul>
<p>其实一个MQ肯定是很复杂的，问这个问题其实是一个开放性问题，主要是想看看有没有从架构的角度整体构思和设计的思维以及能力</p>
<h2 id="消息队列相关问题总结">消息队列相关问题总结</h2>
<p>一般而言，如果一个面试官水平还不错，会沿着从浅入深挖一个点，然后按着这个思路一直问下去，除了这里的七大问题之后，甚至还能挑着你熟悉的一个MQ一直问到源码级别，还可能结合项目来仔细问，先讲讲具体的业务细节，然后将业务跟这些MQ的问题场景结合起来，看看你的每个细节是如何处理和实现的。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">bomir</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-11-13
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://bomir.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/docker-basic/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">Docker基础篇</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/top-command-learn/">
            <span class="next-text nav-default">Linux top命令学习</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "Shaper-fox/hugoblogtalks"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:jinchunw@385@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/Bicomir" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://bomir.top/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2021
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        bomir
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
